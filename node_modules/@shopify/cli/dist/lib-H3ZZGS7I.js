import {
  require_signal_exit
} from "./chunk-QETDXAFX.js";
import {
  require_isexe
} from "./chunk-2AW6NZQ5.js";
import {
  __commonJS,
  __require,
  init_cjs_shims
} from "./chunk-POZ5MGPT.js";

// ../../node_modules/.pnpm/kill-port-process@3.1.0/node_modules/kill-port-process/dist/lib/helpers.js
var require_helpers = __commonJS({
  "../../node_modules/.pnpm/kill-port-process@3.1.0/node_modules/kill-port-process/dist/lib/helpers.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.mergeOptions = exports.arrayifyInput = exports.isNullOrUndefined = void 0;
    function isNullOrUndefined(input) {
      return input == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function arrayifyInput(input) {
      return Array.isArray(input) ? input : [input];
    }
    exports.arrayifyInput = arrayifyInput;
    function mergeOptions(options) {
      return Object.assign(Object.assign({}, {
        signal: "SIGKILL"
      }), options);
    }
    exports.mergeOptions = mergeOptions;
  }
});

// ../../node_modules/.pnpm/which@1.3.1/node_modules/which/which.js
var require_which = __commonJS({
  "../../node_modules/.pnpm/which@1.3.1/node_modules/which/which.js"(exports, module) {
    init_cjs_shims();
    module.exports = which;
    which.sync = whichSync;
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys", path = __require("path"), COLON = isWindows ? ";" : ":", isexe = require_isexe();
    function getNotFoundError(cmd) {
      var er = new Error("not found: " + cmd);
      return er.code = "ENOENT", er;
    }
    function getPathInfo(cmd, opt) {
      var colon = opt.colon || COLON, pathEnv = opt.path || process.env.PATH || "", pathExt = [""];
      pathEnv = pathEnv.split(colon);
      var pathExtExe = "";
      return isWindows && (pathEnv.unshift(process.cwd()), pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM", pathExt = pathExtExe.split(colon), cmd.indexOf(".") !== -1 && pathExt[0] !== "" && pathExt.unshift("")), (cmd.match(/\//) || isWindows && cmd.match(/\\/)) && (pathEnv = [""]), {
        env: pathEnv,
        ext: pathExt,
        extExe: pathExtExe
      };
    }
    function which(cmd, opt, cb) {
      typeof opt == "function" && (cb = opt, opt = {});
      var info = getPathInfo(cmd, opt), pathEnv = info.env, pathExt = info.ext, pathExtExe = info.extExe, found = [];
      (function F(i, l) {
        if (i === l)
          return opt.all && found.length ? cb(null, found) : cb(getNotFoundError(cmd));
        var pathPart = pathEnv[i];
        pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"' && (pathPart = pathPart.slice(1, -1));
        var p = path.join(pathPart, cmd);
        !pathPart && /^\.[\\\/]/.test(cmd) && (p = cmd.slice(0, 2) + p), function E(ii, ll) {
          if (ii === ll)
            return F(i + 1, l);
          var ext = pathExt[ii];
          isexe(p + ext, { pathExt: pathExtExe }, function(er, is) {
            if (!er && is)
              if (opt.all)
                found.push(p + ext);
              else
                return cb(null, p + ext);
            return E(ii + 1, ll);
          });
        }(0, pathExt.length);
      })(0, pathEnv.length);
    }
    function whichSync(cmd, opt) {
      opt = opt || {};
      for (var info = getPathInfo(cmd, opt), pathEnv = info.env, pathExt = info.ext, pathExtExe = info.extExe, found = [], i = 0, l = pathEnv.length; i < l; i++) {
        var pathPart = pathEnv[i];
        pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"' && (pathPart = pathPart.slice(1, -1));
        var p = path.join(pathPart, cmd);
        !pathPart && /^\.[\\\/]/.test(cmd) && (p = cmd.slice(0, 2) + p);
        for (var j = 0, ll = pathExt.length; j < ll; j++) {
          var cur = p + pathExt[j], is;
          try {
            if (is = isexe.sync(cur, { pathExt: pathExtExe }), is)
              if (opt.all)
                found.push(cur);
              else
                return cur;
          } catch {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    }
  }
});

// ../../node_modules/.pnpm/pseudomap@1.0.2/node_modules/pseudomap/pseudomap.js
var require_pseudomap = __commonJS({
  "../../node_modules/.pnpm/pseudomap@1.0.2/node_modules/pseudomap/pseudomap.js"(exports, module) {
    init_cjs_shims();
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    module.exports = PseudoMap;
    function PseudoMap(set2) {
      if (!(this instanceof PseudoMap))
        throw new TypeError("Constructor PseudoMap requires 'new'");
      if (this.clear(), set2)
        if (set2 instanceof PseudoMap || typeof Map == "function" && set2 instanceof Map)
          set2.forEach(function(value, key) {
            this.set(key, value);
          }, this);
        else if (Array.isArray(set2))
          set2.forEach(function(kv) {
            this.set(kv[0], kv[1]);
          }, this);
        else
          throw new TypeError("invalid argument");
    }
    PseudoMap.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this, Object.keys(this._data).forEach(function(k) {
        k !== "size" && fn.call(thisp, this._data[k].value, this._data[k].key);
      }, this);
    };
    PseudoMap.prototype.has = function(k) {
      return !!find(this._data, k);
    };
    PseudoMap.prototype.get = function(k) {
      var res = find(this._data, k);
      return res && res.value;
    };
    PseudoMap.prototype.set = function(k, v) {
      set(this._data, k, v);
    };
    PseudoMap.prototype.delete = function(k) {
      var res = find(this._data, k);
      res && (delete this._data[res._index], this._data.size--);
    };
    PseudoMap.prototype.clear = function() {
      var data = /* @__PURE__ */ Object.create(null);
      data.size = 0, Object.defineProperty(this, "_data", {
        value: data,
        enumerable: !1,
        configurable: !0,
        writable: !1
      });
    };
    Object.defineProperty(PseudoMap.prototype, "size", {
      get: function() {
        return this._data.size;
      },
      set: function(n) {
      },
      enumerable: !0,
      configurable: !0
    });
    PseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function() {
      throw new Error("iterators are not implemented in this version");
    };
    function same(a, b) {
      return a === b || a !== a && b !== b;
    }
    function Entry(k, v, i) {
      this.key = k, this.value = v, this._index = i;
    }
    function find(data, k) {
      for (var i = 0, s = "_" + k, key = s; hasOwnProperty.call(data, key); key = s + i++)
        if (same(data[key].key, k))
          return data[key];
    }
    function set(data, k, v) {
      for (var i = 0, s = "_" + k, key = s; hasOwnProperty.call(data, key); key = s + i++)
        if (same(data[key].key, k)) {
          data[key].value = v;
          return;
        }
      data.size++, data[key] = new Entry(k, v, key);
    }
  }
});

// ../../node_modules/.pnpm/pseudomap@1.0.2/node_modules/pseudomap/map.js
var require_map = __commonJS({
  "../../node_modules/.pnpm/pseudomap@1.0.2/node_modules/pseudomap/map.js"(exports, module) {
    init_cjs_shims();
    process.env.npm_package_name === "pseudomap" && process.env.npm_lifecycle_script === "test" && (process.env.TEST_PSEUDOMAP = "true");
    typeof Map == "function" && !process.env.TEST_PSEUDOMAP ? module.exports = Map : module.exports = require_pseudomap();
  }
});

// ../../node_modules/.pnpm/yallist@2.1.2/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "../../node_modules/.pnpm/yallist@2.1.2/node_modules/yallist/yallist.js"(exports, module) {
    init_cjs_shims();
    module.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self = this;
      if (self instanceof Yallist || (self = new Yallist()), self.tail = null, self.head = null, self.length = 0, list && typeof list.forEach == "function")
        list.forEach(function(item) {
          self.push(item);
        });
      else if (arguments.length > 0)
        for (var i = 0, l = arguments.length; i < l; i++)
          self.push(arguments[i]);
      return self;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this)
        throw new Error("removing node which does not belong to this list");
      var next = node.next, prev = node.prev;
      next && (next.prev = prev), prev && (prev.next = next), node === this.head && (this.head = next), node === this.tail && (this.tail = prev), node.list.length--, node.next = null, node.prev = null, node.list = null;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node !== this.head) {
        node.list && node.list.removeNode(node);
        var head = this.head;
        node.list = this, node.next = head, head && (head.prev = node), this.head = node, this.tail || (this.tail = node), this.length++;
      }
    };
    Yallist.prototype.pushNode = function(node) {
      if (node !== this.tail) {
        node.list && node.list.removeNode(node);
        var tail = this.tail;
        node.list = this, node.prev = tail, tail && (tail.next = node), this.tail = node, this.head || (this.head = node), this.length++;
      }
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++)
        push(this, arguments[i]);
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++)
        unshift(this, arguments[i]);
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (this.tail) {
        var res = this.tail.value;
        return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, res;
      }
    };
    Yallist.prototype.shift = function() {
      if (this.head) {
        var res = this.head.value;
        return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, res;
      }
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++)
        fn.call(thisp, walker.value, i, this), walker = walker.next;
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--)
        fn.call(thisp, walker.value, i, this), walker = walker.prev;
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++)
        walker = walker.next;
      if (i === n && walker !== null)
        return walker.value;
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++)
        walker = walker.prev;
      if (i === n && walker !== null)
        return walker.value;
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      for (var res = new Yallist(), walker = this.head; walker !== null; )
        res.push(fn.call(thisp, walker.value, this)), walker = walker.next;
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var res = new Yallist(), walker = this.tail; walker !== null; )
        res.push(fn.call(thisp, walker.value, this)), walker = walker.prev;
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc, walker = this.head;
      if (arguments.length > 1)
        acc = initial;
      else if (this.head)
        walker = this.head.next, acc = this.head.value;
      else
        throw new TypeError("Reduce of empty list with no initial value");
      for (var i = 0; walker !== null; i++)
        acc = fn(acc, walker.value, i), walker = walker.next;
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc, walker = this.tail;
      if (arguments.length > 1)
        acc = initial;
      else if (this.tail)
        walker = this.tail.prev, acc = this.tail.value;
      else
        throw new TypeError("Reduce of empty list with no initial value");
      for (var i = this.length - 1; walker !== null; i--)
        acc = fn(acc, walker.value, i), walker = walker.prev;
      return acc;
    };
    Yallist.prototype.toArray = function() {
      for (var arr = new Array(this.length), i = 0, walker = this.head; walker !== null; i++)
        arr[i] = walker.value, walker = walker.next;
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      for (var arr = new Array(this.length), i = 0, walker = this.tail; walker !== null; i++)
        arr[i] = walker.value, walker = walker.prev;
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length, to < 0 && (to += this.length), from = from || 0, from < 0 && (from += this.length);
      var ret = new Yallist();
      if (to < from || to < 0)
        return ret;
      from < 0 && (from = 0), to > this.length && (to = this.length);
      for (var i = 0, walker = this.head; walker !== null && i < from; i++)
        walker = walker.next;
      for (; walker !== null && i < to; i++, walker = walker.next)
        ret.push(walker.value);
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length, to < 0 && (to += this.length), from = from || 0, from < 0 && (from += this.length);
      var ret = new Yallist();
      if (to < from || to < 0)
        return ret;
      from < 0 && (from = 0), to > this.length && (to = this.length);
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--)
        walker = walker.prev;
      for (; walker !== null && i > from; i--, walker = walker.prev)
        ret.push(walker.value);
      return ret;
    };
    Yallist.prototype.reverse = function() {
      for (var head = this.head, tail = this.tail, walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next, walker.next = p;
      }
      return this.head = tail, this.tail = head, this;
    };
    function push(self, item) {
      self.tail = new Node(item, self.tail, null, self), self.head || (self.head = self.tail), self.length++;
    }
    function unshift(self, item) {
      self.head = new Node(item, null, self.head, self), self.tail || (self.tail = self.head), self.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node))
        return new Node(value, prev, next, list);
      this.list = list, this.value = value, prev ? (prev.next = this, this.prev = prev) : this.prev = null, next ? (next.prev = this, this.next = next) : this.next = null;
    }
  }
});

// ../../node_modules/.pnpm/lru-cache@4.1.5/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../../node_modules/.pnpm/lru-cache@4.1.5/node_modules/lru-cache/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = LRUCache;
    var Map2 = require_map(), util = __require("util"), Yallist = require_yallist(), hasSymbol = typeof Symbol == "function" && process.env._nodeLRUCacheForceNoSymbol !== "1", makeSymbol;
    hasSymbol ? makeSymbol = function(key) {
      return Symbol(key);
    } : makeSymbol = function(key) {
      return "_" + key;
    };
    var MAX = makeSymbol("max"), LENGTH = makeSymbol("length"), LENGTH_CALCULATOR = makeSymbol("lengthCalculator"), ALLOW_STALE = makeSymbol("allowStale"), MAX_AGE = makeSymbol("maxAge"), DISPOSE = makeSymbol("dispose"), NO_DISPOSE_ON_SET = makeSymbol("noDisposeOnSet"), LRU_LIST = makeSymbol("lruList"), CACHE = makeSymbol("cache");
    function naiveLength() {
      return 1;
    }
    function LRUCache(options) {
      if (!(this instanceof LRUCache))
        return new LRUCache(options);
      typeof options == "number" && (options = { max: options }), options || (options = {});
      var max = this[MAX] = options.max;
      (!max || typeof max != "number" || max <= 0) && (this[MAX] = 1 / 0);
      var lc = options.length || naiveLength;
      typeof lc != "function" && (lc = naiveLength), this[LENGTH_CALCULATOR] = lc, this[ALLOW_STALE] = options.stale || !1, this[MAX_AGE] = options.maxAge || 0, this[DISPOSE] = options.dispose, this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || !1, this.reset();
    }
    Object.defineProperty(LRUCache.prototype, "max", {
      set: function(mL) {
        (!mL || typeof mL != "number" || mL <= 0) && (mL = 1 / 0), this[MAX] = mL, trim(this);
      },
      get: function() {
        return this[MAX];
      },
      enumerable: !0
    });
    Object.defineProperty(LRUCache.prototype, "allowStale", {
      set: function(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      },
      get: function() {
        return this[ALLOW_STALE];
      },
      enumerable: !0
    });
    Object.defineProperty(LRUCache.prototype, "maxAge", {
      set: function(mA) {
        (!mA || typeof mA != "number" || mA < 0) && (mA = 0), this[MAX_AGE] = mA, trim(this);
      },
      get: function() {
        return this[MAX_AGE];
      },
      enumerable: !0
    });
    Object.defineProperty(LRUCache.prototype, "lengthCalculator", {
      set: function(lC) {
        typeof lC != "function" && (lC = naiveLength), lC !== this[LENGTH_CALCULATOR] && (this[LENGTH_CALCULATOR] = lC, this[LENGTH] = 0, this[LRU_LIST].forEach(function(hit) {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key), this[LENGTH] += hit.length;
        }, this)), trim(this);
      },
      get: function() {
        return this[LENGTH_CALCULATOR];
      },
      enumerable: !0
    });
    Object.defineProperty(LRUCache.prototype, "length", {
      get: function() {
        return this[LENGTH];
      },
      enumerable: !0
    });
    Object.defineProperty(LRUCache.prototype, "itemCount", {
      get: function() {
        return this[LRU_LIST].length;
      },
      enumerable: !0
    });
    LRUCache.prototype.rforEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this[LRU_LIST].tail; walker !== null; ) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp), walker = prev;
      }
    };
    function forEachStep(self, fn, node, thisp) {
      var hit = node.value;
      isStale(self, hit) && (del(self, node), self[ALLOW_STALE] || (hit = void 0)), hit && fn.call(thisp, hit.value, hit.key, self);
    }
    LRUCache.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this[LRU_LIST].head; walker !== null; ) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp), walker = next;
      }
    };
    LRUCache.prototype.keys = function() {
      return this[LRU_LIST].toArray().map(function(k) {
        return k.key;
      }, this);
    };
    LRUCache.prototype.values = function() {
      return this[LRU_LIST].toArray().map(function(k) {
        return k.value;
      }, this);
    };
    LRUCache.prototype.reset = function() {
      this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length && this[LRU_LIST].forEach(function(hit) {
        this[DISPOSE](hit.key, hit.value);
      }, this), this[CACHE] = new Map2(), this[LRU_LIST] = new Yallist(), this[LENGTH] = 0;
    };
    LRUCache.prototype.dump = function() {
      return this[LRU_LIST].map(function(hit) {
        if (!isStale(this, hit))
          return {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          };
      }, this).toArray().filter(function(h) {
        return h;
      });
    };
    LRUCache.prototype.dumpLru = function() {
      return this[LRU_LIST];
    };
    LRUCache.prototype.inspect = function(n, opts) {
      var str = "LRUCache {", extras = !1, as = this[ALLOW_STALE];
      as && (str += `
  allowStale: true`, extras = !0);
      var max = this[MAX];
      max && max !== 1 / 0 && (extras && (str += ","), str += `
  max: ` + util.inspect(max, opts), extras = !0);
      var maxAge = this[MAX_AGE];
      maxAge && (extras && (str += ","), str += `
  maxAge: ` + util.inspect(maxAge, opts), extras = !0);
      var lc = this[LENGTH_CALCULATOR];
      lc && lc !== naiveLength && (extras && (str += ","), str += `
  length: ` + util.inspect(this[LENGTH], opts), extras = !0);
      var didFirst = !1;
      return this[LRU_LIST].forEach(function(item) {
        didFirst ? str += `,
  ` : (extras && (str += `,
`), didFirst = !0, str += `
  `);
        var key = util.inspect(item.key).split(`
`).join(`
  `), val = { value: item.value };
        item.maxAge !== maxAge && (val.maxAge = item.maxAge), lc !== naiveLength && (val.length = item.length), isStale(this, item) && (val.stale = !0), val = util.inspect(val, opts).split(`
`).join(`
  `), str += key + " => " + val;
      }), (didFirst || extras) && (str += `
`), str += "}", str;
    };
    LRUCache.prototype.set = function(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      var now = maxAge ? Date.now() : 0, len = this[LENGTH_CALCULATOR](value, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX])
          return del(this, this[CACHE].get(key)), !1;
        var node = this[CACHE].get(key), item = node.value;
        return this[DISPOSE] && (this[NO_DISPOSE_ON_SET] || this[DISPOSE](key, item.value)), item.now = now, item.maxAge = maxAge, item.value = value, this[LENGTH] += len - item.length, item.length = len, this.get(key), trim(this), !0;
      }
      var hit = new Entry(key, value, len, now, maxAge);
      return hit.length > this[MAX] ? (this[DISPOSE] && this[DISPOSE](key, value), !1) : (this[LENGTH] += hit.length, this[LRU_LIST].unshift(hit), this[CACHE].set(key, this[LRU_LIST].head), trim(this), !0);
    };
    LRUCache.prototype.has = function(key) {
      if (!this[CACHE].has(key))
        return !1;
      var hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    };
    LRUCache.prototype.get = function(key) {
      return get(this, key, !0);
    };
    LRUCache.prototype.peek = function(key) {
      return get(this, key, !1);
    };
    LRUCache.prototype.pop = function() {
      var node = this[LRU_LIST].tail;
      return node ? (del(this, node), node.value) : null;
    };
    LRUCache.prototype.del = function(key) {
      del(this, this[CACHE].get(key));
    };
    LRUCache.prototype.load = function(arr) {
      this.reset();
      for (var now = Date.now(), l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l], expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          var maxAge = expiresAt - now;
          maxAge > 0 && this.set(hit.k, hit.v, maxAge);
        }
      }
    };
    LRUCache.prototype.prune = function() {
      var self = this;
      this[CACHE].forEach(function(value, key) {
        get(self, key, !1);
      });
    };
    function get(self, key, doUse) {
      var node = self[CACHE].get(key);
      if (node) {
        var hit = node.value;
        isStale(self, hit) ? (del(self, node), self[ALLOW_STALE] || (hit = void 0)) : doUse && self[LRU_LIST].unshiftNode(node), hit && (hit = hit.value);
      }
      return hit;
    }
    function isStale(self, hit) {
      if (!hit || !hit.maxAge && !self[MAX_AGE])
        return !1;
      var stale = !1, diff = Date.now() - hit.now;
      return hit.maxAge ? stale = diff > hit.maxAge : stale = self[MAX_AGE] && diff > self[MAX_AGE], stale;
    }
    function trim(self) {
      if (self[LENGTH] > self[MAX])
        for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null; ) {
          var prev = walker.prev;
          del(self, walker), walker = prev;
        }
    }
    function del(self, node) {
      if (node) {
        var hit = node.value;
        self[DISPOSE] && self[DISPOSE](hit.key, hit.value), self[LENGTH] -= hit.length, self[CACHE].delete(hit.key), self[LRU_LIST].removeNode(node);
      }
    }
    function Entry(key, value, length, now, maxAge) {
      this.key = key, this.value = value, this.length = length, this.now = now, this.maxAge = maxAge || 0;
    }
  }
});

// ../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var path = __require("path"), which = require_which(), LRU = require_lru_cache(), commandCache = new LRU({ max: 50, maxAge: 30 * 1e3 });
    function resolveCommand(command, noExtension) {
      var resolved;
      if (noExtension = !!noExtension, resolved = commandCache.get(command + "!" + noExtension), commandCache.has(command))
        return commandCache.get(command);
      try {
        resolved = noExtension ? which.sync(command, { pathExt: path.delimiter + (process.env.PATHEXT || "") }) : which.sync(command);
      } catch {
      }
      return commandCache.set(command + "!" + noExtension, resolved), resolved;
    }
    module.exports = resolveCommand;
  }
});

// ../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/hasEmptyArgumentBug.js
var require_hasEmptyArgumentBug = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/hasEmptyArgumentBug.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    function hasEmptyArgumentBug() {
      var nodeVer;
      return process.platform !== "win32" ? !1 : (nodeVer = process.version.substr(1).split(".").map(function(num) {
        return parseInt(num, 10);
      }), nodeVer[0] === 0 && nodeVer[1] < 12);
    }
    module.exports = hasEmptyArgumentBug();
  }
});

// ../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/escapeArgument.js
var require_escapeArgument = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/escapeArgument.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    function escapeArgument(arg, quote) {
      return arg = "" + arg, quote ? (arg = arg.replace(/(\\*)"/g, '$1$1\\"'), arg = arg.replace(/(\\*)$/, "$1$1"), arg = '"' + arg + '"') : arg = arg.replace(/([()%!^<>&|;,"'\s])/g, "^$1"), arg;
    }
    module.exports = escapeArgument;
  }
});

// ../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/escapeCommand.js
var require_escapeCommand = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/escapeCommand.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var escapeArgument = require_escapeArgument();
    function escapeCommand(command) {
      return /^[a-z0-9_-]+$/i.test(command) ? command : escapeArgument(command, !0);
    }
    module.exports = escapeCommand;
  }
});

// ../../node_modules/.pnpm/shebang-regex@1.0.0/node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "../../node_modules/.pnpm/shebang-regex@1.0.0/node_modules/shebang-regex/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = /^#!.*/;
  }
});

// ../../node_modules/.pnpm/shebang-command@1.2.0/node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "../../node_modules/.pnpm/shebang-command@1.2.0/node_modules/shebang-command/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var shebangRegex = require_shebang_regex();
    module.exports = function(str) {
      var match = str.match(shebangRegex);
      if (!match)
        return null;
      var arr = match[0].replace(/#! ?/, "").split(" "), bin = arr[0].split("/").pop(), arg = arr[1];
      return bin === "env" ? arg : bin + (arg ? " " + arg : "");
    };
  }
});

// ../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/util/readShebang.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var fs = __require("fs"), LRU = require_lru_cache(), shebangCommand = require_shebang_command(), shebangCache = new LRU({ max: 50, maxAge: 30 * 1e3 });
    function readShebang(command) {
      var buffer, fd, shebang;
      if (shebangCache.has(command))
        return shebangCache.get(command);
      buffer = new Buffer(150);
      try {
        fd = fs.openSync(command, "r"), fs.readSync(fd, buffer, 0, 150, 0), fs.closeSync(fd);
      } catch {
      }
      return shebang = shebangCommand(buffer.toString()), shebangCache.set(command, shebang), shebang;
    }
    module.exports = readShebang;
  }
});

// ../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/parse.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var resolveCommand = require_resolveCommand(), hasEmptyArgumentBug = require_hasEmptyArgumentBug(), escapeArgument = require_escapeArgument(), escapeCommand = require_escapeCommand(), readShebang = require_readShebang(), isWin = process.platform === "win32", skipShellRegExp = /\.(?:com|exe)$/i, supportsShellOption = parseInt(process.version.substr(1).split(".")[0], 10) >= 6 || parseInt(process.version.substr(1).split(".")[0], 10) === 4 && parseInt(process.version.substr(1).split(".")[1], 10) >= 8;
    function parseNonShell(parsed) {
      var shebang, needsShell, applyQuotes;
      return isWin && (parsed.file = resolveCommand(parsed.command), parsed.file = parsed.file || resolveCommand(parsed.command, !0), shebang = parsed.file && readShebang(parsed.file), shebang ? (parsed.args.unshift(parsed.file), parsed.command = shebang, needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(resolveCommand(shebang) || resolveCommand(shebang, !0))) : needsShell = hasEmptyArgumentBug || !skipShellRegExp.test(parsed.file), needsShell && (applyQuotes = parsed.command !== "echo", parsed.command = escapeCommand(parsed.command), parsed.args = parsed.args.map(function(arg) {
        return escapeArgument(arg, applyQuotes);
      }), parsed.args = ["/d", "/s", "/c", '"' + parsed.command + (parsed.args.length ? " " + parsed.args.join(" ") : "") + '"'], parsed.command = process.env.comspec || "cmd.exe", parsed.options.windowsVerbatimArguments = !0)), parsed;
    }
    function parseShell(parsed) {
      var shellCommand;
      return supportsShellOption || (shellCommand = [parsed.command].concat(parsed.args).join(" "), isWin ? (parsed.command = typeof parsed.options.shell == "string" ? parsed.options.shell : process.env.comspec || "cmd.exe", parsed.args = ["/d", "/s", "/c", '"' + shellCommand + '"'], parsed.options.windowsVerbatimArguments = !0) : (typeof parsed.options.shell == "string" ? parsed.command = parsed.options.shell : process.platform === "android" ? parsed.command = "/system/bin/sh" : parsed.command = "/bin/sh", parsed.args = ["-c", shellCommand])), parsed;
    }
    function parse(command, args, options) {
      var parsed;
      return args && !Array.isArray(args) && (options = args, args = null), args = args ? args.slice(0) : [], options = options || {}, parsed = {
        command,
        args,
        options,
        file: void 0,
        original: command
      }, options.shell ? parseShell(parsed) : parseNonShell(parsed);
    }
    module.exports = parse;
  }
});

// ../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/lib/enoent.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var isWin = process.platform === "win32", resolveCommand = require_resolveCommand(), isNode10 = process.version.indexOf("v0.10.") === 0;
    function notFoundError(command, syscall) {
      var err;
      return err = new Error(syscall + " " + command + " ENOENT"), err.code = err.errno = "ENOENT", err.syscall = syscall + " " + command, err;
    }
    function hookChildProcess(cp, parsed) {
      var originalEmit;
      isWin && (originalEmit = cp.emit, cp.emit = function(name, arg1) {
        var err;
        return name === "exit" && (err = verifyENOENT(arg1, parsed, "spawn"), err) ? originalEmit.call(cp, "error", err) : originalEmit.apply(cp, arguments);
      });
    }
    function verifyENOENT(status, parsed) {
      return isWin && status === 1 && !parsed.file ? notFoundError(parsed.original, "spawn") : null;
    }
    function verifyENOENTSync(status, parsed) {
      return isWin && status === 1 && !parsed.file || isNode10 && status === -1 && (parsed.file = isWin ? parsed.file : resolveCommand(parsed.original), !parsed.file) ? notFoundError(parsed.original, "spawnSync") : null;
    }
    module.exports.hookChildProcess = hookChildProcess;
    module.exports.verifyENOENT = verifyENOENT;
    module.exports.verifyENOENTSync = verifyENOENTSync;
    module.exports.notFoundError = notFoundError;
  }
});

// ../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "../../node_modules/.pnpm/cross-spawn@5.1.0/node_modules/cross-spawn/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var cp = __require("child_process"), parse = require_parse(), enoent = require_enoent(), cpSpawnSync = cp.spawnSync;
    function spawn(command, args, options) {
      var parsed, spawned;
      return parsed = parse(command, args, options), spawned = cp.spawn(parsed.command, parsed.args, parsed.options), enoent.hookChildProcess(spawned, parsed), spawned;
    }
    function spawnSync(command, args, options) {
      var parsed, result;
      if (!cpSpawnSync)
        try {
          cpSpawnSync = __require("spawn-sync");
        } catch {
          throw new Error(
            `In order to use spawnSync on node 0.10 or older, you must install spawn-sync:

  npm install spawn-sync --save`
          );
        }
      return parsed = parse(command, args, options), result = cpSpawnSync(parsed.command, parsed.args, parsed.options), result.error = result.error || enoent.verifyENOENTSync(result.status, parsed), result;
    }
    module.exports = spawn;
    module.exports.spawn = spawn;
    module.exports.sync = spawnSync;
    module.exports._parse = parse;
    module.exports._enoent = enoent;
  }
});

// ../../node_modules/.pnpm/strip-eof@1.0.0/node_modules/strip-eof/index.js
var require_strip_eof = __commonJS({
  "../../node_modules/.pnpm/strip-eof@1.0.0/node_modules/strip-eof/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = function(x) {
      var lf = typeof x == "string" ? `
` : 10, cr = typeof x == "string" ? "\r" : 13;
      return x[x.length - 1] === lf && (x = x.slice(0, x.length - 1)), x[x.length - 1] === cr && (x = x.slice(0, x.length - 1)), x;
    };
  }
});

// ../../node_modules/.pnpm/path-key@2.0.1/node_modules/path-key/index.js
var require_path_key = __commonJS({
  "../../node_modules/.pnpm/path-key@2.0.1/node_modules/path-key/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = (opts) => {
      opts = opts || {};
      let env = opts.env || process.env;
      return (opts.platform || process.platform) !== "win32" ? "PATH" : Object.keys(env).find((x) => x.toUpperCase() === "PATH") || "Path";
    };
  }
});

// ../../node_modules/.pnpm/npm-run-path@2.0.2/node_modules/npm-run-path/index.js
var require_npm_run_path = __commonJS({
  "../../node_modules/.pnpm/npm-run-path@2.0.2/node_modules/npm-run-path/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var path = __require("path"), pathKey = require_path_key();
    module.exports = (opts) => {
      opts = Object.assign({
        cwd: process.cwd(),
        path: process.env[pathKey()]
      }, opts);
      let prev, pth = path.resolve(opts.cwd), ret = [];
      for (; prev !== pth; )
        ret.push(path.join(pth, "node_modules/.bin")), prev = pth, pth = path.resolve(pth, "..");
      return ret.push(path.dirname(process.execPath)), ret.concat(opts.path).join(path.delimiter);
    };
    module.exports.env = (opts) => {
      opts = Object.assign({
        env: process.env
      }, opts);
      let env = Object.assign({}, opts.env), path2 = pathKey({ env });
      return opts.path = env[path2], env[path2] = module.exports(opts), env;
    };
  }
});

// ../../node_modules/.pnpm/is-stream@1.1.0/node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "../../node_modules/.pnpm/is-stream@1.1.0/node_modules/is-stream/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var isStream = module.exports = function(stream) {
      return stream !== null && typeof stream == "object" && typeof stream.pipe == "function";
    };
    isStream.writable = function(stream) {
      return isStream(stream) && stream.writable !== !1 && typeof stream._write == "function" && typeof stream._writableState == "object";
    };
    isStream.readable = function(stream) {
      return isStream(stream) && stream.readable !== !1 && typeof stream._read == "function" && typeof stream._readableState == "object";
    };
    isStream.duplex = function(stream) {
      return isStream.writable(stream) && isStream.readable(stream);
    };
    isStream.transform = function(stream) {
      return isStream.duplex(stream) && typeof stream._transform == "function" && typeof stream._transformState == "object";
    };
  }
});

// ../../node_modules/.pnpm/get-stream@3.0.0/node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "../../node_modules/.pnpm/get-stream@3.0.0/node_modules/get-stream/buffer-stream.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var PassThrough = __require("stream").PassThrough;
    module.exports = (opts) => {
      opts = Object.assign({}, opts);
      let array = opts.array, encoding = opts.encoding, buffer = encoding === "buffer", objectMode = !1;
      array ? objectMode = !(encoding || buffer) : encoding = encoding || "utf8", buffer && (encoding = null);
      let len = 0, ret = [], stream = new PassThrough({ objectMode });
      return encoding && stream.setEncoding(encoding), stream.on("data", (chunk) => {
        ret.push(chunk), objectMode ? len = ret.length : len += chunk.length;
      }), stream.getBufferedValue = () => array ? ret : buffer ? Buffer.concat(ret, len) : ret.join(""), stream.getBufferedLength = () => len, stream;
    };
  }
});

// ../../node_modules/.pnpm/get-stream@3.0.0/node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "../../node_modules/.pnpm/get-stream@3.0.0/node_modules/get-stream/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var bufferStream = require_buffer_stream();
    function getStream(inputStream, opts) {
      if (!inputStream)
        return Promise.reject(new Error("Expected a stream"));
      opts = Object.assign({ maxBuffer: 1 / 0 }, opts);
      let maxBuffer = opts.maxBuffer, stream, clean, p = new Promise((resolve, reject) => {
        let error = (err) => {
          err && (err.bufferedData = stream.getBufferedValue()), reject(err);
        };
        stream = bufferStream(opts), inputStream.once("error", error), inputStream.pipe(stream), stream.on("data", () => {
          stream.getBufferedLength() > maxBuffer && reject(new Error("maxBuffer exceeded"));
        }), stream.once("error", error), stream.on("end", resolve), clean = () => {
          inputStream.unpipe && inputStream.unpipe(stream);
        };
      });
      return p.then(clean, clean), p.then(() => stream.getBufferedValue());
    }
    module.exports = getStream;
    module.exports.buffer = (stream, opts) => getStream(stream, Object.assign({}, opts, { encoding: "buffer" }));
    module.exports.array = (stream, opts) => getStream(stream, Object.assign({}, opts, { array: !0 }));
  }
});

// ../../node_modules/.pnpm/p-finally@1.0.0/node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "../../node_modules/.pnpm/p-finally@1.0.0/node_modules/p-finally/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    module.exports = (promise, onFinally) => (onFinally = onFinally || (() => {
    }), promise.then(
      (val) => new Promise((resolve) => {
        resolve(onFinally());
      }).then(() => val),
      (err) => new Promise((resolve) => {
        resolve(onFinally());
      }).then(() => {
        throw err;
      })
    ));
  }
});

// ../../node_modules/.pnpm/execa@0.9.0/node_modules/execa/lib/errname.js
var require_errname = __commonJS({
  "../../node_modules/.pnpm/execa@0.9.0/node_modules/execa/lib/errname.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var uv;
    try {
      if (uv = process.binding("uv"), typeof uv.errname != "function")
        throw new TypeError("uv.errname is not a function");
    } catch (err) {
      console.error("execa/lib/errname: unable to establish process.binding('uv')", err), uv = null;
    }
    function errname(uv2, code) {
      if (uv2)
        return uv2.errname(code);
      if (!(code < 0))
        throw new Error("err >= 0");
      return `Unknown system error ${code}`;
    }
    module.exports = (code) => errname(uv, code);
    module.exports.__test__ = errname;
  }
});

// ../../node_modules/.pnpm/execa@0.9.0/node_modules/execa/lib/stdio.js
var require_stdio = __commonJS({
  "../../node_modules/.pnpm/execa@0.9.0/node_modules/execa/lib/stdio.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var alias = ["stdin", "stdout", "stderr"], hasAlias = (opts) => alias.some((x) => !!opts[x]);
    module.exports = (opts) => {
      if (!opts)
        return null;
      if (opts.stdio && hasAlias(opts))
        throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${alias.map((x) => `\`${x}\``).join(", ")}`);
      if (typeof opts.stdio == "string")
        return opts.stdio;
      let stdio = opts.stdio || [];
      if (!Array.isArray(stdio))
        throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
      let result = [], len = Math.max(stdio.length, alias.length);
      for (let i = 0; i < len; i++) {
        let value = null;
        stdio[i] !== void 0 ? value = stdio[i] : opts[alias[i]] !== void 0 && (value = opts[alias[i]]), result[i] = value;
      }
      return result;
    };
  }
});

// ../../node_modules/.pnpm/execa@0.9.0/node_modules/execa/index.js
var require_execa = __commonJS({
  "../../node_modules/.pnpm/execa@0.9.0/node_modules/execa/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var path = __require("path"), childProcess = __require("child_process"), util = __require("util"), crossSpawn = require_cross_spawn(), stripEof = require_strip_eof(), npmRunPath = require_npm_run_path(), isStream = require_is_stream(), _getStream = require_get_stream(), pFinally = require_p_finally(), onExit = require_signal_exit(), errname = require_errname(), stdio = require_stdio(), TEN_MEGABYTES = 1e3 * 1e3 * 10;
    function handleArgs(cmd, args, opts) {
      let parsed;
      return opts = Object.assign({
        extendEnv: !0,
        env: {}
      }, opts), opts.extendEnv && (opts.env = Object.assign({}, process.env, opts.env)), opts.__winShell === !0 ? (delete opts.__winShell, parsed = {
        command: cmd,
        args,
        options: opts,
        file: cmd,
        original: cmd
      }) : parsed = crossSpawn._parse(cmd, args, opts), opts = Object.assign({
        maxBuffer: TEN_MEGABYTES,
        stripEof: !0,
        preferLocal: !0,
        localDir: parsed.options.cwd || process.cwd(),
        encoding: "utf8",
        reject: !0,
        cleanup: !0
      }, parsed.options), opts.stdio = stdio(opts), opts.preferLocal && (opts.env = npmRunPath.env(Object.assign({}, opts, { cwd: opts.localDir }))), opts.detached && (opts.cleanup = !1), process.platform === "win32" && path.basename(parsed.command) === "cmd.exe" && parsed.args.unshift("/q"), {
        cmd: parsed.command,
        args: parsed.args,
        opts,
        parsed
      };
    }
    function handleInput(spawned, opts) {
      let input = opts.input;
      input != null && (isStream(input) ? input.pipe(spawned.stdin) : spawned.stdin.end(input));
    }
    function handleOutput(opts, val) {
      return val && opts.stripEof && (val = stripEof(val)), val;
    }
    function handleShell(fn, cmd, opts) {
      let file = "/bin/sh", args = ["-c", cmd];
      return opts = Object.assign({}, opts), process.platform === "win32" && (opts.__winShell = !0, file = process.env.comspec || "cmd.exe", args = ["/s", "/c", `"${cmd}"`], opts.windowsVerbatimArguments = !0), opts.shell && (file = opts.shell, delete opts.shell), fn(file, args, opts);
    }
    function getStream(process2, stream, encoding, maxBuffer) {
      if (!process2[stream])
        return null;
      let ret;
      return encoding ? ret = _getStream(process2[stream], {
        encoding,
        maxBuffer
      }) : ret = _getStream.buffer(process2[stream], { maxBuffer }), ret.catch((err) => {
        throw err.stream = stream, err.message = `${stream} ${err.message}`, err;
      });
    }
    function makeError(result, options) {
      let stdout = result.stdout, stderr = result.stderr, err = result.error, code = result.code, signal = result.signal, parsed = options.parsed, joinedCmd = options.joinedCmd, timedOut = options.timedOut || !1;
      if (!err) {
        let output = "";
        Array.isArray(parsed.opts.stdio) ? (parsed.opts.stdio[2] !== "inherit" && (output += output.length > 0 ? stderr : `
${stderr}`), parsed.opts.stdio[1] !== "inherit" && (output += `
${stdout}`)) : parsed.opts.stdio !== "inherit" && (output = `
${stderr}${stdout}`), err = new Error(`Command failed: ${joinedCmd}${output}`), err.code = code < 0 ? errname(code) : code;
      }
      return err.stdout = stdout, err.stderr = stderr, err.failed = !0, err.signal = signal || null, err.cmd = joinedCmd, err.timedOut = timedOut, err;
    }
    function joinCmd(cmd, args) {
      let joinedCmd = cmd;
      return Array.isArray(args) && args.length > 0 && (joinedCmd += " " + args.join(" ")), joinedCmd;
    }
    module.exports = (cmd, args, opts) => {
      let parsed = handleArgs(cmd, args, opts), encoding = parsed.opts.encoding, maxBuffer = parsed.opts.maxBuffer, joinedCmd = joinCmd(cmd, args), spawned;
      try {
        spawned = childProcess.spawn(parsed.cmd, parsed.args, parsed.opts);
      } catch (err) {
        return Promise.reject(err);
      }
      let removeExitHandler;
      parsed.opts.cleanup && (removeExitHandler = onExit(() => {
        spawned.kill();
      }));
      let timeoutId = null, timedOut = !1, cleanupTimeout = () => {
        timeoutId && (clearTimeout(timeoutId), timeoutId = null);
      };
      parsed.opts.timeout > 0 && (timeoutId = setTimeout(() => {
        timeoutId = null, timedOut = !0, spawned.kill(parsed.opts.killSignal);
      }, parsed.opts.timeout));
      let processDone = new Promise((resolve) => {
        spawned.on("exit", (code, signal) => {
          cleanupTimeout(), resolve({ code, signal });
        }), spawned.on("error", (err) => {
          cleanupTimeout(), resolve({ error: err });
        }), spawned.stdin && spawned.stdin.on("error", (err) => {
          cleanupTimeout(), resolve({ error: err });
        });
      });
      function destroy() {
        spawned.stdout && spawned.stdout.destroy(), spawned.stderr && spawned.stderr.destroy();
      }
      let handlePromise = () => pFinally(Promise.all([
        processDone,
        getStream(spawned, "stdout", encoding, maxBuffer),
        getStream(spawned, "stderr", encoding, maxBuffer)
      ]).then((arr) => {
        let result = arr[0];
        if (result.stdout = arr[1], result.stderr = arr[2], removeExitHandler && removeExitHandler(), result.error || result.code !== 0 || result.signal !== null) {
          let err = makeError(result, {
            joinedCmd,
            parsed,
            timedOut
          });
          if (err.killed = err.killed || spawned.killed, !parsed.opts.reject)
            return err;
          throw err;
        }
        return {
          stdout: handleOutput(parsed.opts, result.stdout),
          stderr: handleOutput(parsed.opts, result.stderr),
          code: 0,
          failed: !1,
          killed: !1,
          signal: null,
          cmd: joinedCmd,
          timedOut: !1
        };
      }), destroy);
      return crossSpawn._enoent.hookChildProcess(spawned, parsed.parsed), handleInput(spawned, parsed.opts), spawned.then = (onfulfilled, onrejected) => handlePromise().then(onfulfilled, onrejected), spawned.catch = (onrejected) => handlePromise().catch(onrejected), spawned;
    };
    module.exports.stdout = function() {
      return module.exports.apply(null, arguments).then((x) => x.stdout);
    };
    module.exports.stderr = function() {
      return module.exports.apply(null, arguments).then((x) => x.stderr);
    };
    module.exports.shell = (cmd, opts) => handleShell(module.exports, cmd, opts);
    module.exports.sync = (cmd, args, opts) => {
      let parsed = handleArgs(cmd, args, opts), joinedCmd = joinCmd(cmd, args);
      if (isStream(parsed.opts.input))
        throw new TypeError("The `input` option cannot be a stream in sync mode");
      let result = childProcess.spawnSync(parsed.cmd, parsed.args, parsed.opts);
      if (result.code = result.status, result.error || result.status !== 0 || result.signal !== null) {
        let err = makeError(result, {
          joinedCmd,
          parsed
        });
        if (!parsed.opts.reject)
          return err;
        throw err;
      }
      return {
        stdout: handleOutput(parsed.opts, result.stdout),
        stderr: handleOutput(parsed.opts, result.stderr),
        code: 0,
        failed: !1,
        signal: null,
        cmd: joinedCmd,
        timedOut: !1
      };
    };
    module.exports.shellSync = (cmd, opts) => handleShell(module.exports.sync, cmd, opts);
    module.exports.spawn = util.deprecate(module.exports, "execa.spawn() is deprecated. Use execa() instead.");
  }
});

// ../../node_modules/.pnpm/pid-from-port@1.1.3/node_modules/pid-from-port/index.js
var require_pid_from_port = __commonJS({
  "../../node_modules/.pnpm/pid-from-port@1.1.3/node_modules/pid-from-port/index.js"(exports, module) {
    "use strict";
    init_cjs_shims();
    var execa = require_execa(), macos = () => execa.stdout("netstat", ["-anv", "-p", "tcp"]).then((data) => Promise.all([data, execa.stdout("netstat", ["-anv", "-p", "udp"])])).then((data) => data.join(`
`)), linux = () => execa.stdout("ss", ["-tunlp"]), win32 = () => execa.stdout("netstat", ["-ano"]), getListFn = process.platform === "darwin" ? macos : process.platform === "linux" ? linux : win32, cols = process.platform === "darwin" ? [3, 8] : process.platform === "linux" ? [4, 6] : [1, 4], isProtocol = (x) => /^\s*(tcp|udp)/i.test(x), parsePid = (input) => {
      if (typeof input != "string")
        return null;
      let match = input.match(/(?:^|",|",pid=)(\d+)/);
      return match ? parseInt(match[1], 10) : null;
    }, getPort = (input, list) => {
      let regex = new RegExp(`[.:]${input}$`), port = list.find((x) => regex.test(x[cols[0]]));
      if (!port)
        throw new Error(`Couldn't find a process with port \`${input}\``);
      return parsePid(port[cols[1]]);
    }, getList = () => getListFn().then(
      (list) => list.split(`
`).reduce((result, x) => (isProtocol(x) && result.push(x.match(/\S+/g) || []), result), [])
    );
    module.exports = (input) => typeof input != "number" ? Promise.reject(new TypeError(`Expected a number, got ${typeof input}`)) : getList().then((list) => getPort(input, list));
    module.exports.all = (input) => Array.isArray(input) ? getList().then((list) => Promise.all(input.map((x) => [x, getPort(x, list)]))).then((list) => new Map(list)) : Promise.reject(new TypeError(`Expected an array, got ${typeof input}`));
    module.exports.list = () => getList().then((list) => {
      let ret = /* @__PURE__ */ new Map();
      for (let x of list) {
        let match = x[cols[0]].match(/[^]*[.:](\d+)$/);
        match && ret.set(parseInt(match[1], 10), parsePid(x[cols[1]]));
      }
      return ret;
    });
  }
});

// ../../node_modules/.pnpm/kill-port-process@3.1.0/node_modules/kill-port-process/dist/lib/killer.js
var require_killer = __commonJS({
  "../../node_modules/.pnpm/kill-port-process@3.1.0/node_modules/kill-port-process/dist/lib/killer.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.Killer = void 0;
    var child_process_1 = __require("child_process"), os_1 = __require("os"), pidFromPort = require_pid_from_port(), Killer = class {
      constructor(ports) {
        this.ports = ports;
      }
      kill(options) {
        return __awaiter(this, void 0, void 0, function* () {
          let killFunc = os_1.platform() === "win32" ? this.win32Kill : this.unixKill, promises = this.ports.map((port) => killFunc(port, options.signal));
          return Promise.all(promises);
        });
      }
      win32Kill(port, signal) {
        return __awaiter(this, void 0, void 0, function* () {
          let pid = yield pidFromPort(port).catch((error) => console.error("Failed to get pid of port", port, error));
          if (pid)
            return new Promise((resolve, reject) => {
              let taskkill = child_process_1.spawn("TASKKILL", ["/f", "/t", "/pid", pid.toString()]);
              taskkill.stdout.on("data", (data) => console.log(data.toString())), taskkill.stderr.on("data", (data) => console.error(data.toString())), taskkill.on("close", (code, signal2) => {
                if (code !== 0)
                  return reject(`taskkill process exited with code ${code} and signal ${signal2}`);
                resolve(void 0);
              }), taskkill.on("error", (err) => reject(err));
            });
        });
      }
      unixKill(port, signal) {
        return __awaiter(this, void 0, void 0, function* () {
          let killCommand = {
            SIGKILL: "-9",
            SIGTERM: "-15"
          }[signal];
          return new Promise((resolve, reject) => {
            let lsof = child_process_1.spawn("lsof", ["-i", `tcp:${port}`]), grep = child_process_1.spawn("grep", ["LISTEN"]), awk = child_process_1.spawn("awk", ["{print $2}"]), xargs = child_process_1.spawn("xargs", ["kill", killCommand]);
            lsof.stdout.pipe(grep.stdin), lsof.stderr.on("data", logStderrData("lsof")), grep.stdout.pipe(awk.stdin), grep.stderr.on("data", logStderrData("grep")), awk.stdout.pipe(xargs.stdin), awk.stderr.on("data", logStderrData("awk")), xargs.stdout.pipe(process.stdin), xargs.stderr.on("data", logStderrData("xargs")), xargs.on("close", (code) => {
              if (code !== 0)
                return reject();
              resolve(void 0);
            });
            function logStderrData(command) {
              return (data) => console.error(`${command} - ${data.toString()}`);
            }
          });
        });
      }
    };
    exports.Killer = Killer;
  }
});

// ../../node_modules/.pnpm/kill-port-process@3.1.0/node_modules/kill-port-process/dist/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/kill-port-process@3.1.0/node_modules/kill-port-process/dist/lib/index.js"(exports) {
    init_cjs_shims();
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.killPortProcess = void 0;
    var helpers_1 = require_helpers(), killer_1 = require_killer();
    function killPortProcess(inputPorts, inputOptions = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        if (helpers_1.isNullOrUndefined(inputPorts))
          throw new Error("No ports found in input");
        let options = helpers_1.mergeOptions(inputOptions), toNumber = (value) => Number(value), ports = helpers_1.arrayifyInput(inputPorts).map(toNumber);
        yield new killer_1.Killer(ports).kill({
          signal: options.signal
        });
      });
    }
    exports.killPortProcess = killPortProcess;
  }
});
export default require_lib();
//# sourceMappingURL=lib-H3ZZGS7I.js.map
