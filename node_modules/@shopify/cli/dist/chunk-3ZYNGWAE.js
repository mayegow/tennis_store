import {
  z
} from "./chunk-NLUGD7PZ.js";
import {
  AbortError,
  BugError,
  outputInfo,
  renderAutocompletePrompt,
  renderConcurrent,
  renderConfirmationPrompt,
  renderFatalError,
  renderInfo,
  renderSelectPrompt,
  renderSuccess,
  renderTable,
  renderTasks,
  renderTextPrompt,
  renderWarning,
  sleep
} from "./chunk-YK3ZIR2O.js";
import {
  init_cjs_shims
} from "./chunk-POZ5MGPT.js";

// src/cli/services/demo.ts
init_cjs_shims();
function oneOrMore(singular) {
  return z.union([singular, z.array(singular)]);
}
var scalar = z.union([z.string(), z.number(), z.boolean(), z.null(), z.undefined()]), linkSchema = z.object({ label: z.string(), url: z.string() }), inlineTokenSchema = z.union([
  z.string(),
  z.object({ command: z.string() }),
  z.object({ link: linkSchema }),
  z.object({ char: z.string().length(1) }),
  z.object({ userInput: z.string() }),
  z.object({ subdued: z.string() }),
  z.object({ filePath: z.string() }),
  z.object({ bold: z.string() })
]), headlineTokenSchema = oneOrMore(
  z.union([
    z.string(),
    z.object({ command: z.string() }),
    z.object({ char: z.string().length(1) }),
    z.object({ userInput: z.string() }),
    z.object({ subdued: z.string() }),
    z.object({ filePath: z.string() })
  ])
), inlineTokenItemSchema = oneOrMore(inlineTokenSchema), listSchema = z.object({
  list: z.object({
    title: z.string().optional(),
    items: z.array(inlineTokenItemSchema),
    ordered: z.boolean().optional()
  })
}), tokenItemSchema = oneOrMore(z.union([inlineTokenSchema, listSchema])), tableSchema = z.object({
  rows: z.array(z.object({}).catchall(scalar)),
  columns: z.object({}).catchall(
    z.object({
      header: z.string().optional(),
      color: z.string().optional()
    })
  )
}), infoTableSchema = z.union([
  z.object({}).catchall(z.array(inlineTokenItemSchema)),
  z.array(
    z.object({
      color: z.string().optional(),
      header: z.string(),
      helperText: z.string().optional(),
      bullet: z.string().optional(),
      items: z.array(inlineTokenItemSchema)
    })
  )
]), abstractDemoStepSchema = z.object({
  type: z.string(),
  properties: z.object({}),
  // optional properties for documentation purposes
  title: z.string().optional(),
  description: z.string().optional()
}), outputStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("output"),
  properties: z.object({
    content: z.string()
  })
}), renderStepPropertiesSchema = z.object({
  headline: headlineTokenSchema.optional(),
  body: tokenItemSchema.optional(),
  nextSteps: z.array(inlineTokenItemSchema).optional(),
  reference: z.array(inlineTokenItemSchema).optional(),
  link: linkSchema.optional(),
  customSections: z.array(
    z.object({
      title: z.string().optional(),
      body: tokenItemSchema
    })
  ).optional(),
  orderedNextSteps: z.boolean().optional()
}), renderInfoStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("info"),
  properties: renderStepPropertiesSchema
}), renderSuccessStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("success"),
  properties: renderStepPropertiesSchema
}), renderWarningStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("warning"),
  properties: renderStepPropertiesSchema
}), renderFatalErrorStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("fatalError"),
  properties: z.object({
    errorType: z.union([z.literal("abort"), z.literal("bug")]),
    message: z.string(),
    tryMessage: z.string().optional(),
    nextSteps: z.array(inlineTokenItemSchema).optional()
  })
}), renderTableStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("table"),
  properties: tableSchema
}), renderAutoCompletePromptStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("autocompletePrompt"),
  properties: z.object({
    message: z.string(),
    choices: z.array(
      z.object({
        label: z.string(),
        value: z.string()
      })
    )
  })
}), renderConfirmationPromptStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("confirmationPrompt"),
  properties: z.object({
    message: headlineTokenSchema,
    infoTable: infoTableSchema.optional(),
    defaultValue: z.boolean().optional(),
    confirmationMessage: z.string(),
    cancellationMessage: z.string()
  })
}), renderSelectPromptStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("selectPrompt"),
  properties: z.object({
    message: headlineTokenSchema,
    choices: z.array(
      z.object({
        label: z.string(),
        value: z.string(),
        key: z.string().length(1).optional(),
        group: z.string().optional(),
        disabled: z.boolean().optional()
      })
    ),
    defaultValue: z.string().optional(),
    infoTable: infoTableSchema.optional()
  })
}), renderTextPromptStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("textPrompt"),
  properties: z.object({
    message: z.string(),
    defaultValue: z.string().optional(),
    password: z.boolean().optional(),
    allowEmpty: z.boolean().optional()
  })
}), sleepStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("sleep"),
  properties: z.object({
    duration: z.number()
  })
}), taskbarStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("taskbar"),
  properties: z.object({
    steps: z.array(
      z.object({
        title: z.string(),
        duration: z.number()
      })
    )
  })
}), renderConcurrentPropertiesSchema = z.object({
  processes: z.array(
    z.object({
      prefix: z.string(),
      steps: z.array(
        z.object({
          startMessage: z.string().optional(),
          duration: z.number(),
          endMessage: z.string().optional()
        })
      )
    })
  )
}), renderConcurrentStepSchema = abstractDemoStepSchema.extend({
  type: z.literal("concurrent"),
  properties: renderConcurrentPropertiesSchema
}), demoStepSchema = z.discriminatedUnion("type", [
  outputStepSchema,
  renderInfoStepSchema,
  renderSuccessStepSchema,
  renderWarningStepSchema,
  renderTableStepSchema,
  renderFatalErrorStepSchema,
  renderAutoCompletePromptStepSchema,
  renderConfirmationPromptStepSchema,
  renderSelectPromptStepSchema,
  renderTextPromptStepSchema,
  sleepStepSchema,
  taskbarStepSchema,
  renderConcurrentStepSchema
]), demoStepsSchema = z.object({
  $schema: z.string().optional(),
  command: z.string().optional(),
  steps: z.array(demoStepSchema)
});
async function demo(stepsJsonData) {
  let { steps, command } = demoStepsSchema.parse(stepsJsonData), executors = steps.map(executorForStep);
  await simulateTyping(command);
  for (let executor of executors)
    await executor();
}
async function simulateTyping(text) {
  if (!text)
    return;
  console.clear(), process.stdout.write("$ ");
  let chars = text.split("");
  for (; chars.length > 0; ) {
    let char = chars.shift();
    process.stdout.write(char), await sleep(0.1 + Math.random() / 10);
  }
  process.stdout.write(`
`), await sleep(1 + Math.random() / 10);
}
function executorForStep(step) {
  switch (step.type) {
    case "output":
      return async () => {
        outputInfo(step.properties.content);
      };
    case "sleep":
      return async () => {
        await sleep(step.properties.duration);
      };
    case "taskbar":
      return taskbarExecutor(step.properties.steps);
    case "concurrent":
      return concurrentExecutor(step.properties);
    case "info":
      return async () => {
        renderInfo(step.properties);
      };
    case "success":
      return async () => {
        renderSuccess(step.properties);
      };
    case "warning":
      return async () => {
        renderWarning(step.properties);
      };
    case "fatalError":
      return async () => {
        let { errorType, message, nextSteps, tryMessage } = step.properties;
        errorType === "abort" ? renderFatalError(new AbortError(message, tryMessage, nextSteps)) : renderFatalError(new BugError(message, tryMessage));
      };
    case "table":
      return async () => {
        renderTable(step.properties);
      };
    case "autocompletePrompt":
      return async () => {
        await renderAutocompletePrompt(step.properties);
      };
    case "confirmationPrompt":
      return async () => {
        await renderConfirmationPrompt(step.properties);
      };
    case "selectPrompt":
      return async () => {
        await renderSelectPrompt(step.properties);
      };
    case "textPrompt":
      return async () => {
        await renderTextPrompt(step.properties);
      };
    default:
      throw new Error(`Unknown step type: ${step.type}`);
  }
}
function taskbarExecutor(steps) {
  return async () => {
    let tasks = steps.map(({ title, duration }) => ({
      title,
      task: async () => sleep(duration)
    }));
    await renderTasks(tasks);
  };
}
function concurrentExecutor({ processes }) {
  return async () => {
    let concurrentProcesses = processes.map(({ prefix, steps }) => ({
      prefix,
      action: async (stdout) => {
        for (let step of steps) {
          let { startMessage, duration, endMessage } = step;
          startMessage && stdout.write(startMessage), await sleep(duration), endMessage && stdout.write(endMessage);
        }
      }
    }));
    await renderConcurrent({ processes: concurrentProcesses });
  };
}

export {
  demoStepsSchema,
  demo
};
//# sourceMappingURL=chunk-3ZYNGWAE.js.map
