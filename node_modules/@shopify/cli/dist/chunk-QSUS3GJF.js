import {
  __commonJS,
  init_cjs_shims
} from "./chunk-POZ5MGPT.js";

// ../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/helpers/util.js
var require_util = __commonJS({
  "../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/helpers/util.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getParsedType = exports.ZodParsedType = exports.objectUtil = exports.util = void 0;
    var util;
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever, util2.arrayToEnum = (items) => {
        let obj = {};
        for (let item of items)
          obj[item] = item;
        return obj;
      }, util2.getValidEnumValues = (obj) => {
        let validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] != "number"), filtered = {};
        for (let k of validKeys)
          filtered[k] = obj[k];
        return util2.objectValues(filtered);
      }, util2.objectValues = (obj) => util2.objectKeys(obj).map(function(e) {
        return obj[e];
      }), util2.objectKeys = typeof Object.keys == "function" ? (obj) => Object.keys(obj) : (object) => {
        let keys = [];
        for (let key in object)
          Object.prototype.hasOwnProperty.call(object, key) && keys.push(key);
        return keys;
      }, util2.find = (arr, checker) => {
        for (let item of arr)
          if (checker(item))
            return item;
      }, util2.isInteger = typeof Number.isInteger == "function" ? (val) => Number.isInteger(val) : (val) => typeof val == "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val == "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues, util2.jsonStringifyReplacer = (_, value) => typeof value == "bigint" ? value.toString() : value;
    })(util = exports.util || (exports.util = {}));
    var objectUtil;
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => ({
        ...first,
        ...second
      });
    })(objectUtil = exports.objectUtil || (exports.objectUtil = {}));
    exports.ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    var getParsedType = (data) => {
      switch (typeof data) {
        case "undefined":
          return exports.ZodParsedType.undefined;
        case "string":
          return exports.ZodParsedType.string;
        case "number":
          return isNaN(data) ? exports.ZodParsedType.nan : exports.ZodParsedType.number;
        case "boolean":
          return exports.ZodParsedType.boolean;
        case "function":
          return exports.ZodParsedType.function;
        case "bigint":
          return exports.ZodParsedType.bigint;
        case "symbol":
          return exports.ZodParsedType.symbol;
        case "object":
          return Array.isArray(data) ? exports.ZodParsedType.array : data === null ? exports.ZodParsedType.null : data.then && typeof data.then == "function" && data.catch && typeof data.catch == "function" ? exports.ZodParsedType.promise : typeof Map < "u" && data instanceof Map ? exports.ZodParsedType.map : typeof Set < "u" && data instanceof Set ? exports.ZodParsedType.set : typeof Date < "u" && data instanceof Date ? exports.ZodParsedType.date : exports.ZodParsedType.object;
        default:
          return exports.ZodParsedType.unknown;
      }
    };
    exports.getParsedType = getParsedType;
  }
});

// ../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/ZodError.js
var require_ZodError = __commonJS({
  "../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/ZodError.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ZodError = exports.quotelessJson = exports.ZodIssueCode = void 0;
    var util_1 = require_util();
    exports.ZodIssueCode = util_1.util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    var quotelessJson = (obj) => JSON.stringify(obj, null, 2).replace(/"([^"]+)":/g, "$1:");
    exports.quotelessJson = quotelessJson;
    var ZodError = class extends Error {
      constructor(issues) {
        super(), this.issues = [], this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        }, this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        let actualProto = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, actualProto) : this.__proto__ = actualProto, this.name = "ZodError", this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        let mapper = _mapper || function(issue) {
          return issue.message;
        }, fieldErrors = { _errors: [] }, processError = (error) => {
          for (let issue of error.issues)
            if (issue.code === "invalid_union")
              issue.unionErrors.map(processError);
            else if (issue.code === "invalid_return_type")
              processError(issue.returnTypeError);
            else if (issue.code === "invalid_arguments")
              processError(issue.argumentsError);
            else if (issue.path.length === 0)
              fieldErrors._errors.push(mapper(issue));
            else {
              let curr = fieldErrors, i = 0;
              for (; i < issue.path.length; ) {
                let el = issue.path[i];
                i === issue.path.length - 1 ? (curr[el] = curr[el] || { _errors: [] }, curr[el]._errors.push(mapper(issue))) : curr[el] = curr[el] || { _errors: [] }, curr = curr[el], i++;
              }
            }
        };
        return processError(this), fieldErrors;
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util_1.util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        let fieldErrors = {}, formErrors = [];
        for (let sub of this.issues)
          sub.path.length > 0 ? (fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [], fieldErrors[sub.path[0]].push(mapper(sub))) : formErrors.push(mapper(sub));
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    exports.ZodError = ZodError;
    ZodError.create = (issues) => new ZodError(issues);
  }
});

// ../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/locales/en.js
var require_en = __commonJS({
  "../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/locales/en.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var util_1 = require_util(), ZodError_1 = require_ZodError(), errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodError_1.ZodIssueCode.invalid_type:
          issue.received === util_1.ZodParsedType.undefined ? message = "Required" : message = `Expected ${issue.expected}, received ${issue.received}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util_1.util.jsonStringifyReplacer)}`;
          break;
        case ZodError_1.ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util_1.util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_union:
          message = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util_1.util.joinValues(issue.options)}`;
          break;
        case ZodError_1.ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util_1.util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodError_1.ZodIssueCode.invalid_arguments:
          message = "Invalid function arguments";
          break;
        case ZodError_1.ZodIssueCode.invalid_return_type:
          message = "Invalid function return type";
          break;
        case ZodError_1.ZodIssueCode.invalid_date:
          message = "Invalid date";
          break;
        case ZodError_1.ZodIssueCode.invalid_string:
          typeof issue.validation == "object" ? "includes" in issue.validation ? (message = `Invalid input: must include "${issue.validation.includes}"`, typeof issue.validation.position == "number" && (message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`)) : "startsWith" in issue.validation ? message = `Invalid input: must start with "${issue.validation.startsWith}"` : "endsWith" in issue.validation ? message = `Invalid input: must end with "${issue.validation.endsWith}"` : util_1.util.assertNever(issue.validation) : issue.validation !== "regex" ? message = `Invalid ${issue.validation}` : message = "Invalid";
          break;
        case ZodError_1.ZodIssueCode.too_small:
          issue.type === "array" ? message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? "at least" : "more than"} ${issue.minimum} element(s)` : issue.type === "string" ? message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? "at least" : "over"} ${issue.minimum} character(s)` : issue.type === "number" ? message = `Number must be ${issue.exact ? "exactly equal to " : issue.inclusive ? "greater than or equal to " : "greater than "}${issue.minimum}` : issue.type === "date" ? message = `Date must be ${issue.exact ? "exactly equal to " : issue.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(issue.minimum))}` : message = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.too_big:
          issue.type === "array" ? message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? "at most" : "less than"} ${issue.maximum} element(s)` : issue.type === "string" ? message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? "at most" : "under"} ${issue.maximum} character(s)` : issue.type === "number" ? message = `Number must be ${issue.exact ? "exactly" : issue.inclusive ? "less than or equal to" : "less than"} ${issue.maximum}` : issue.type === "bigint" ? message = `BigInt must be ${issue.exact ? "exactly" : issue.inclusive ? "less than or equal to" : "less than"} ${issue.maximum}` : issue.type === "date" ? message = `Date must be ${issue.exact ? "exactly" : issue.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(issue.maximum))}` : message = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.custom:
          message = "Invalid input";
          break;
        case ZodError_1.ZodIssueCode.invalid_intersection_types:
          message = "Intersection results could not be merged";
          break;
        case ZodError_1.ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodError_1.ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError, util_1.util.assertNever(issue);
      }
      return { message };
    };
    exports.default = errorMap;
  }
});

// ../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/errors.js
var require_errors = __commonJS({
  "../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/errors.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getErrorMap = exports.setErrorMap = exports.defaultErrorMap = void 0;
    var en_1 = __importDefault(require_en());
    exports.defaultErrorMap = en_1.default;
    var overrideErrorMap = en_1.default;
    function setErrorMap(map) {
      overrideErrorMap = map;
    }
    exports.setErrorMap = setErrorMap;
    function getErrorMap() {
      return overrideErrorMap;
    }
    exports.getErrorMap = getErrorMap;
  }
});

// ../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/helpers/parseUtil.js
var require_parseUtil = __commonJS({
  "../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/helpers/parseUtil.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.isAsync = exports.isValid = exports.isDirty = exports.isAborted = exports.OK = exports.DIRTY = exports.INVALID = exports.ParseStatus = exports.addIssueToContext = exports.EMPTY_PATH = exports.makeIssue = void 0;
    var errors_1 = require_errors(), en_1 = __importDefault(require_en()), makeIssue = (params) => {
      let { data, path, errorMaps, issueData } = params, fullPath = [...path, ...issueData.path || []], fullIssue = {
        ...issueData,
        path: fullPath
      }, errorMessage = "", maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (let map of maps)
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage
      };
    };
    exports.makeIssue = makeIssue;
    exports.EMPTY_PATH = [];
    function addIssueToContext(ctx, issueData) {
      let issue = (0, exports.makeIssue)({
        issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          (0, errors_1.getErrorMap)(),
          en_1.default
        ].filter((x) => !!x)
      });
      ctx.common.issues.push(issue);
    }
    exports.addIssueToContext = addIssueToContext;
    var ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        this.value === "valid" && (this.value = "dirty");
      }
      abort() {
        this.value !== "aborted" && (this.value = "aborted");
      }
      static mergeArray(status, results) {
        let arrayValue = [];
        for (let s of results) {
          if (s.status === "aborted")
            return exports.INVALID;
          s.status === "dirty" && status.dirty(), arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        let syncPairs = [];
        for (let pair of pairs)
          syncPairs.push({
            key: await pair.key,
            value: await pair.value
          });
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        let finalObject = {};
        for (let pair of pairs) {
          let { key, value } = pair;
          if (key.status === "aborted" || value.status === "aborted")
            return exports.INVALID;
          key.status === "dirty" && status.dirty(), value.status === "dirty" && status.dirty(), key.value !== "__proto__" && (typeof value.value < "u" || pair.alwaysSet) && (finalObject[key.value] = value.value);
        }
        return { status: status.value, value: finalObject };
      }
    };
    exports.ParseStatus = ParseStatus;
    exports.INVALID = Object.freeze({
      status: "aborted"
    });
    var DIRTY = (value) => ({ status: "dirty", value });
    exports.DIRTY = DIRTY;
    var OK = (value) => ({ status: "valid", value });
    exports.OK = OK;
    var isAborted = (x) => x.status === "aborted";
    exports.isAborted = isAborted;
    var isDirty = (x) => x.status === "dirty";
    exports.isDirty = isDirty;
    var isValid = (x) => x.status === "valid";
    exports.isValid = isValid;
    var isAsync = (x) => typeof Promise < "u" && x instanceof Promise;
    exports.isAsync = isAsync;
  }
});

// ../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/helpers/typeAliases.js
var require_typeAliases = __commonJS({
  "../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/helpers/typeAliases.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
  }
});

// ../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/helpers/errorUtil.js
var require_errorUtil = __commonJS({
  "../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/helpers/errorUtil.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.errorUtil = void 0;
    var errorUtil;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message == "string" ? { message } : message || {}, errorUtil2.toString = (message) => typeof message == "string" ? message : message?.message;
    })(errorUtil = exports.errorUtil || (exports.errorUtil = {}));
  }
});

// ../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/types.js
var require_types = __commonJS({
  "../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/types.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.date = exports.boolean = exports.bigint = exports.array = exports.any = exports.coerce = exports.ZodFirstPartyTypeKind = exports.late = exports.ZodSchema = exports.Schema = exports.custom = exports.ZodReadonly = exports.ZodPipeline = exports.ZodBranded = exports.BRAND = exports.ZodNaN = exports.ZodCatch = exports.ZodDefault = exports.ZodNullable = exports.ZodOptional = exports.ZodTransformer = exports.ZodEffects = exports.ZodPromise = exports.ZodNativeEnum = exports.ZodEnum = exports.ZodLiteral = exports.ZodLazy = exports.ZodFunction = exports.ZodSet = exports.ZodMap = exports.ZodRecord = exports.ZodTuple = exports.ZodIntersection = exports.ZodDiscriminatedUnion = exports.ZodUnion = exports.ZodObject = exports.ZodArray = exports.ZodVoid = exports.ZodNever = exports.ZodUnknown = exports.ZodAny = exports.ZodNull = exports.ZodUndefined = exports.ZodSymbol = exports.ZodDate = exports.ZodBoolean = exports.ZodBigInt = exports.ZodNumber = exports.ZodString = exports.ZodType = void 0;
    exports.NEVER = exports.void = exports.unknown = exports.union = exports.undefined = exports.tuple = exports.transformer = exports.symbol = exports.string = exports.strictObject = exports.set = exports.record = exports.promise = exports.preprocess = exports.pipeline = exports.ostring = exports.optional = exports.onumber = exports.oboolean = exports.object = exports.number = exports.nullable = exports.null = exports.never = exports.nativeEnum = exports.nan = exports.map = exports.literal = exports.lazy = exports.intersection = exports.instanceof = exports.function = exports.enum = exports.effect = exports.discriminatedUnion = void 0;
    var errors_1 = require_errors(), errorUtil_1 = require_errorUtil(), parseUtil_1 = require_parseUtil(), util_1 = require_util(), ZodError_1 = require_ZodError(), ParseInputLazyPath = class {
      constructor(parent, value, path, key) {
        this._cachedPath = [], this.parent = parent, this.data = value, this._path = path, this._key = key;
      }
      get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
      }
    }, handleResult = (ctx, result) => {
      if ((0, parseUtil_1.isValid)(result))
        return { success: !0, data: result.value };
      if (!ctx.common.issues.length)
        throw new Error("Validation failed but no issues detected.");
      return {
        success: !1,
        get error() {
          if (this._error)
            return this._error;
          let error = new ZodError_1.ZodError(ctx.common.issues);
          return this._error = error, this._error;
        }
      };
    };
    function processCreateParams(params) {
      if (!params)
        return {};
      let { errorMap, invalid_type_error, required_error, description } = params;
      if (errorMap && (invalid_type_error || required_error))
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
      return errorMap ? { errorMap, description } : { errorMap: (iss, ctx) => iss.code !== "invalid_type" ? { message: ctx.defaultError } : typeof ctx.data > "u" ? { message: required_error ?? ctx.defaultError } : { message: invalid_type_error ?? ctx.defaultError }, description };
    }
    var ZodType = class {
      constructor(def) {
        this.spa = this.safeParseAsync, this._def = def, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return (0, util_1.getParsedType)(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: (0, util_1.getParsedType)(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new parseUtil_1.ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, util_1.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        let result = this._parse(input);
        if ((0, parseUtil_1.isAsync)(result))
          throw new Error("Synchronous parse encountered promise.");
        return result;
      }
      _parseAsync(input) {
        let result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        let result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a;
        let ctx = {
          common: {
            issues: [],
            async: (_a = params?.async) !== null && _a !== void 0 ? _a : !1,
            contextualErrorMap: params?.errorMap
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        }, result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      async parseAsync(data, params) {
        let result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        let ctx = {
          common: {
            issues: [],
            contextualErrorMap: params?.errorMap,
            async: !0
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: (0, util_1.getParsedType)(data)
        }, maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx }), result = await ((0, parseUtil_1.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        let getIssueProperties = (val) => typeof message == "string" || typeof message > "u" ? { message } : typeof message == "function" ? message(val) : message;
        return this._refinement((val, ctx) => {
          let result = check(val), setError = () => ctx.addIssue({
            code: ZodError_1.ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          return typeof Promise < "u" && result instanceof Promise ? result.then((data) => data ? !0 : (setError(), !1)) : result ? !0 : (setError(), !1);
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => check(val) ? !0 : (ctx.addIssue(typeof refinementData == "function" ? refinementData(val, ctx) : refinementData), !1));
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this, this._def);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        let defaultValueFunc = typeof def == "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        let catchValueFunc = typeof def == "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        let This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    exports.ZodType = ZodType;
    exports.Schema = ZodType;
    exports.ZodSchema = ZodType;
    var cuidRegex = /^c[^\s-]{8,}$/i, cuid2Regex = /^[a-z][a-z0-9]*$/, ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/, uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u, ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, datetimeRegex = (args) => args.precision ? args.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`) : args.precision === 0 ? args.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : args.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
    function isValidIP(ip, version) {
      return !!((version === "v4" || !version) && ipv4Regex.test(ip) || (version === "v6" || !version) && ipv6Regex.test(ip));
    }
    var ZodString = class _ZodString extends ZodType {
      constructor() {
        super(...arguments), this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
          validation,
          code: ZodError_1.ZodIssueCode.invalid_string,
          ...errorUtil_1.errorUtil.errToObj(message)
        }), this.nonempty = (message) => this.min(1, errorUtil_1.errorUtil.errToObj(message)), this.trim = () => new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        }), this.toLowerCase = () => new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        }), this.toUpperCase = () => new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      _parse(input) {
        if (this._def.coerce && (input.data = String(input.data)), this._getType(input) !== util_1.ZodParsedType.string) {
          let ctx2 = this._getOrReturnCtx(input);
          return (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.string,
            received: ctx2.parsedType
          }), parseUtil_1.INVALID;
        }
        let status = new parseUtil_1.ParseStatus(), ctx;
        for (let check of this._def.checks)
          if (check.kind === "min")
            input.data.length < check.value && (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: !0,
              exact: !1,
              message: check.message
            }), status.dirty());
          else if (check.kind === "max")
            input.data.length > check.value && (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: !0,
              exact: !1,
              message: check.message
            }), status.dirty());
          else if (check.kind === "length") {
            let tooBig = input.data.length > check.value, tooSmall = input.data.length < check.value;
            (tooBig || tooSmall) && (ctx = this._getOrReturnCtx(input, ctx), tooBig ? (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: !0,
              exact: !0,
              message: check.message
            }) : tooSmall && (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: !0,
              exact: !0,
              message: check.message
            }), status.dirty());
          } else if (check.kind === "email")
            emailRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "email",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            }), status.dirty());
          else if (check.kind === "emoji")
            emojiRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "emoji",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            }), status.dirty());
          else if (check.kind === "uuid")
            uuidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "uuid",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            }), status.dirty());
          else if (check.kind === "cuid")
            cuidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "cuid",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            }), status.dirty());
          else if (check.kind === "cuid2")
            cuid2Regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "cuid2",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            }), status.dirty());
          else if (check.kind === "ulid")
            ulidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "ulid",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            }), status.dirty());
          else if (check.kind === "url")
            try {
              new URL(input.data);
            } catch {
              ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
                validation: "url",
                code: ZodError_1.ZodIssueCode.invalid_string,
                message: check.message
              }), status.dirty();
            }
          else
            check.kind === "regex" ? (check.regex.lastIndex = 0, check.regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "regex",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            }), status.dirty())) : check.kind === "trim" ? input.data = input.data.trim() : check.kind === "includes" ? input.data.includes(check.value, check.position) || (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            }), status.dirty()) : check.kind === "toLowerCase" ? input.data = input.data.toLowerCase() : check.kind === "toUpperCase" ? input.data = input.data.toUpperCase() : check.kind === "startsWith" ? input.data.startsWith(check.value) || (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            }), status.dirty()) : check.kind === "endsWith" ? input.data.endsWith(check.value) || (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            }), status.dirty()) : check.kind === "datetime" ? datetimeRegex(check).test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            }), status.dirty()) : check.kind === "ip" ? isValidIP(input.data, check.version) || (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
              validation: "ip",
              code: ZodError_1.ZodIssueCode.invalid_string,
              message: check.message
            }), status.dirty()) : util_1.util.assertNever(check);
        return { status: status.value, value: input.data };
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil_1.errorUtil.errToObj(message) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil_1.errorUtil.errToObj(options) });
      }
      datetime(options) {
        var _a;
        return typeof options == "string" ? this._addCheck({
          kind: "datetime",
          precision: null,
          offset: !1,
          message: options
        }) : this._addCheck({
          kind: "datetime",
          precision: typeof options?.precision > "u" ? null : options?.precision,
          offset: (_a = options?.offset) !== null && _a !== void 0 ? _a : !1,
          ...errorUtil_1.errorUtil.errToObj(options?.message)
        });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options?.position,
          ...errorUtil_1.errorUtil.errToObj(options?.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil_1.errorUtil.errToObj(message)
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get minLength() {
        let min = null;
        for (let ch of this._def.checks)
          ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
        return min;
      }
      get maxLength() {
        let max = null;
        for (let ch of this._def.checks)
          ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
        return max;
      }
    };
    exports.ZodString = ZodString;
    ZodString.create = (params) => {
      var _a;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params?.coerce) !== null && _a !== void 0 ? _a : !1,
        ...processCreateParams(params)
      });
    };
    function floatSafeRemainder(val, step) {
      let valDecCount = (val.toString().split(".")[1] || "").length, stepDecCount = (step.toString().split(".")[1] || "").length, decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount, valInt = parseInt(val.toFixed(decCount).replace(".", "")), stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
      return valInt % stepInt / Math.pow(10, decCount);
    }
    var ZodNumber = class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce && (input.data = Number(input.data)), this._getType(input) !== util_1.ZodParsedType.number) {
          let ctx2 = this._getOrReturnCtx(input);
          return (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.number,
            received: ctx2.parsedType
          }), parseUtil_1.INVALID;
        }
        let ctx, status = new parseUtil_1.ParseStatus();
        for (let check of this._def.checks)
          check.kind === "int" ? util_1.util.isInteger(input.data) || (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          }), status.dirty()) : check.kind === "min" ? (check.inclusive ? input.data < check.value : input.data <= check.value) && (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: !1,
            message: check.message
          }), status.dirty()) : check.kind === "max" ? (check.inclusive ? input.data > check.value : input.data >= check.value) && (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: !1,
            message: check.message
          }), status.dirty()) : check.kind === "multipleOf" ? floatSafeRemainder(input.data, check.value) !== 0 && (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          }), status.dirty()) : check.kind === "finite" ? Number.isFinite(input.data) || (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.not_finite,
            message: check.message
          }), status.dirty()) : util_1.util.assertNever(check);
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, !0, errorUtil_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, !1, errorUtil_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, !0, errorUtil_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, !1, errorUtil_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: !1,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: !1,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: !0,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: !0,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: !0,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil_1.errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: !0,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (let ch of this._def.checks)
          ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
        return min;
      }
      get maxValue() {
        let max = null;
        for (let ch of this._def.checks)
          ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util_1.util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null, min = null;
        for (let ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf")
            return !0;
          ch.kind === "min" ? (min === null || ch.value > min) && (min = ch.value) : ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    exports.ZodNumber = ZodNumber;
    ZodNumber.create = (params) => new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: params?.coerce || !1,
      ...processCreateParams(params)
    });
    var ZodBigInt = class _ZodBigInt extends ZodType {
      constructor() {
        super(...arguments), this.min = this.gte, this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce && (input.data = BigInt(input.data)), this._getType(input) !== util_1.ZodParsedType.bigint) {
          let ctx2 = this._getOrReturnCtx(input);
          return (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.bigint,
            received: ctx2.parsedType
          }), parseUtil_1.INVALID;
        }
        let ctx, status = new parseUtil_1.ParseStatus();
        for (let check of this._def.checks)
          check.kind === "min" ? (check.inclusive ? input.data < check.value : input.data <= check.value) && (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          }), status.dirty()) : check.kind === "max" ? (check.inclusive ? input.data > check.value : input.data >= check.value) && (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          }), status.dirty()) : check.kind === "multipleOf" ? input.data % check.value !== BigInt(0) && (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          }), status.dirty()) : util_1.util.assertNever(check);
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, !0, errorUtil_1.errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, !1, errorUtil_1.errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, !0, errorUtil_1.errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, !1, errorUtil_1.errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil_1.errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: !1,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: !1,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: !0,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: !0,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (let ch of this._def.checks)
          ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
        return min;
      }
      get maxValue() {
        let max = null;
        for (let ch of this._def.checks)
          ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
        return max;
      }
    };
    exports.ZodBigInt = ZodBigInt;
    ZodBigInt.create = (params) => {
      var _a;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params?.coerce) !== null && _a !== void 0 ? _a : !1,
        ...processCreateParams(params)
      });
    };
    var ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce && (input.data = !!input.data), this._getType(input) !== util_1.ZodParsedType.boolean) {
          let ctx = this._getOrReturnCtx(input);
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.boolean,
            received: ctx.parsedType
          }), parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodBoolean = ZodBoolean;
    ZodBoolean.create = (params) => new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: params?.coerce || !1,
      ...processCreateParams(params)
    });
    var ZodDate = class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce && (input.data = new Date(input.data)), this._getType(input) !== util_1.ZodParsedType.date) {
          let ctx2 = this._getOrReturnCtx(input);
          return (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.date,
            received: ctx2.parsedType
          }), parseUtil_1.INVALID;
        }
        if (isNaN(input.data.getTime())) {
          let ctx2 = this._getOrReturnCtx(input);
          return (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_date
          }), parseUtil_1.INVALID;
        }
        let status = new parseUtil_1.ParseStatus(), ctx;
        for (let check of this._def.checks)
          check.kind === "min" ? input.data.getTime() < check.value && (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            message: check.message,
            inclusive: !0,
            exact: !1,
            minimum: check.value,
            type: "date"
          }), status.dirty()) : check.kind === "max" ? input.data.getTime() > check.value && (ctx = this._getOrReturnCtx(input, ctx), (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_big,
            message: check.message,
            inclusive: !0,
            exact: !1,
            maximum: check.value,
            type: "date"
          }), status.dirty()) : util_1.util.assertNever(check);
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil_1.errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (let ch of this._def.checks)
          ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (let ch of this._def.checks)
          ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
        return max != null ? new Date(max) : null;
      }
    };
    exports.ZodDate = ZodDate;
    ZodDate.create = (params) => new ZodDate({
      checks: [],
      coerce: params?.coerce || !1,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
    var ZodSymbol = class extends ZodType {
      _parse(input) {
        if (this._getType(input) !== util_1.ZodParsedType.symbol) {
          let ctx = this._getOrReturnCtx(input);
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.symbol,
            received: ctx.parsedType
          }), parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodSymbol = ZodSymbol;
    ZodSymbol.create = (params) => new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
    var ZodUndefined = class extends ZodType {
      _parse(input) {
        if (this._getType(input) !== util_1.ZodParsedType.undefined) {
          let ctx = this._getOrReturnCtx(input);
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.undefined,
            received: ctx.parsedType
          }), parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodUndefined = ZodUndefined;
    ZodUndefined.create = (params) => new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
    var ZodNull = class extends ZodType {
      _parse(input) {
        if (this._getType(input) !== util_1.ZodParsedType.null) {
          let ctx = this._getOrReturnCtx(input);
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.null,
            received: ctx.parsedType
          }), parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodNull = ZodNull;
    ZodNull.create = (params) => new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
    var ZodAny = class extends ZodType {
      constructor() {
        super(...arguments), this._any = !0;
      }
      _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodAny = ZodAny;
    ZodAny.create = (params) => new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
    var ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments), this._unknown = !0;
      }
      _parse(input) {
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodUnknown = ZodUnknown;
    ZodUnknown.create = (params) => new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
    var ZodNever = class extends ZodType {
      _parse(input) {
        let ctx = this._getOrReturnCtx(input);
        return (0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_type,
          expected: util_1.ZodParsedType.never,
          received: ctx.parsedType
        }), parseUtil_1.INVALID;
      }
    };
    exports.ZodNever = ZodNever;
    ZodNever.create = (params) => new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
    var ZodVoid = class extends ZodType {
      _parse(input) {
        if (this._getType(input) !== util_1.ZodParsedType.undefined) {
          let ctx = this._getOrReturnCtx(input);
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.void,
            received: ctx.parsedType
          }), parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
    };
    exports.ZodVoid = ZodVoid;
    ZodVoid.create = (params) => new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
    var ZodArray = class _ZodArray extends ZodType {
      _parse(input) {
        let { ctx, status } = this._processInputParams(input), def = this._def;
        if (ctx.parsedType !== util_1.ZodParsedType.array)
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.array,
            received: ctx.parsedType
          }), parseUtil_1.INVALID;
        if (def.exactLength !== null) {
          let tooBig = ctx.data.length > def.exactLength.value, tooSmall = ctx.data.length < def.exactLength.value;
          (tooBig || tooSmall) && ((0, parseUtil_1.addIssueToContext)(ctx, {
            code: tooBig ? ZodError_1.ZodIssueCode.too_big : ZodError_1.ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: !0,
            exact: !0,
            message: def.exactLength.message
          }), status.dirty());
        }
        if (def.minLength !== null && ctx.data.length < def.minLength.value && ((0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: def.minLength.message
        }), status.dirty()), def.maxLength !== null && ctx.data.length > def.maxLength.value && ((0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: def.maxLength.message
        }), status.dirty()), ctx.common.async)
          return Promise.all([...ctx.data].map((item, i) => def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i)))).then((result2) => parseUtil_1.ParseStatus.mergeArray(status, result2));
        let result = [...ctx.data].map((item, i) => def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        return parseUtil_1.ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports.ZodArray = ZodArray;
    ZodArray.create = (schema, params) => new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
    function deepPartialify(schema) {
      if (schema instanceof ZodObject) {
        let newShape = {};
        for (let key in schema.shape) {
          let fieldSchema = schema.shape[key];
          newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
          ...schema._def,
          shape: () => newShape
        });
      } else
        return schema instanceof ZodArray ? new ZodArray({
          ...schema._def,
          type: deepPartialify(schema.element)
        }) : schema instanceof ZodOptional ? ZodOptional.create(deepPartialify(schema.unwrap())) : schema instanceof ZodNullable ? ZodNullable.create(deepPartialify(schema.unwrap())) : schema instanceof ZodTuple ? ZodTuple.create(schema.items.map((item) => deepPartialify(item))) : schema;
    }
    var ZodObject = class _ZodObject extends ZodType {
      constructor() {
        super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        let shape = this._def.shape(), keys = util_1.util.objectKeys(shape);
        return this._cached = { shape, keys };
      }
      _parse(input) {
        if (this._getType(input) !== util_1.ZodParsedType.object) {
          let ctx2 = this._getOrReturnCtx(input);
          return (0, parseUtil_1.addIssueToContext)(ctx2, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx2.parsedType
          }), parseUtil_1.INVALID;
        }
        let { status, ctx } = this._processInputParams(input), { shape, keys: shapeKeys } = this._getCached(), extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip"))
          for (let key in ctx.data)
            shapeKeys.includes(key) || extraKeys.push(key);
        let pairs = [];
        for (let key of shapeKeys) {
          let keyValidator = shape[key], value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          let unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough")
            for (let key of extraKeys)
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
          else if (unknownKeys === "strict")
            extraKeys.length > 0 && ((0, parseUtil_1.addIssueToContext)(ctx, {
              code: ZodError_1.ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            }), status.dirty());
          else if (unknownKeys !== "strip")
            throw new Error("Internal ZodObject error: invalid unknownKeys value.");
        } else {
          let catchall = this._def.catchall;
          for (let key of extraKeys) {
            let value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
              alwaysSet: key in ctx.data
            });
          }
        }
        return ctx.common.async ? Promise.resolve().then(async () => {
          let syncPairs = [];
          for (let pair of pairs) {
            let key = await pair.key;
            syncPairs.push({
              key,
              value: await pair.value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => parseUtil_1.ParseStatus.mergeObjectSync(status, syncPairs)) : parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        return errorUtil_1.errorUtil.errToObj, new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              let defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              return issue.code === "unrecognized_keys" ? {
                message: (_d = errorUtil_1.errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
              } : {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      merge(merging) {
        return new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
      }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      catchall(index) {
        return new _ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        let shape = {};
        return util_1.util.objectKeys(mask).forEach((key) => {
          mask[key] && this.shape[key] && (shape[key] = this.shape[key]);
        }), new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        let shape = {};
        return util_1.util.objectKeys(this.shape).forEach((key) => {
          mask[key] || (shape[key] = this.shape[key]);
        }), new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        let newShape = {};
        return util_1.util.objectKeys(this.shape).forEach((key) => {
          let fieldSchema = this.shape[key];
          mask && !mask[key] ? newShape[key] = fieldSchema : newShape[key] = fieldSchema.optional();
        }), new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        let newShape = {};
        return util_1.util.objectKeys(this.shape).forEach((key) => {
          if (mask && !mask[key])
            newShape[key] = this.shape[key];
          else {
            let newField = this.shape[key];
            for (; newField instanceof ZodOptional; )
              newField = newField._def.innerType;
            newShape[key] = newField;
          }
        }), new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util_1.util.objectKeys(this.shape));
      }
    };
    exports.ZodObject = ZodObject;
    ZodObject.create = (shape, params) => new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
    ZodObject.strictCreate = (shape, params) => new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
    ZodObject.lazycreate = (shape, params) => new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
    var ZodUnion = class extends ZodType {
      _parse(input) {
        let { ctx } = this._processInputParams(input), options = this._def.options;
        function handleResults(results) {
          for (let result of results)
            if (result.result.status === "valid")
              return result.result;
          for (let result of results)
            if (result.result.status === "dirty")
              return ctx.common.issues.push(...result.ctx.common.issues), result.result;
          let unionErrors = results.map((result) => new ZodError_1.ZodError(result.ctx.common.issues));
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union,
            unionErrors
          }), parseUtil_1.INVALID;
        }
        if (ctx.common.async)
          return Promise.all(options.map(async (option) => {
            let childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        {
          let dirty, issues = [];
          for (let option of options) {
            let childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            }, result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid")
              return result;
            result.status === "dirty" && !dirty && (dirty = { result, ctx: childCtx }), childCtx.common.issues.length && issues.push(childCtx.common.issues);
          }
          if (dirty)
            return ctx.common.issues.push(...dirty.ctx.common.issues), dirty.result;
          let unionErrors = issues.map((issues2) => new ZodError_1.ZodError(issues2));
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_union,
            unionErrors
          }), parseUtil_1.INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    exports.ZodUnion = ZodUnion;
    ZodUnion.create = (types, params) => new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
    var getDiscriminator = (type) => type instanceof ZodLazy ? getDiscriminator(type.schema) : type instanceof ZodEffects ? getDiscriminator(type.innerType()) : type instanceof ZodLiteral ? [type.value] : type instanceof ZodEnum ? type.options : type instanceof ZodNativeEnum ? Object.keys(type.enum) : type instanceof ZodDefault ? getDiscriminator(type._def.innerType) : type instanceof ZodUndefined ? [void 0] : type instanceof ZodNull ? [null] : null, ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        let { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object)
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx.parsedType
          }), parseUtil_1.INVALID;
        let discriminator = this.discriminator, discriminatorValue = ctx.data[discriminator], option = this.optionsMap.get(discriminatorValue);
        return option ? ctx.common.async ? option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }) : option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }) : ((0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        }), parseUtil_1.INVALID);
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      static create(discriminator, options, params) {
        let optionsMap = /* @__PURE__ */ new Map();
        for (let type of options) {
          let discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues)
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          for (let value of discriminatorValues) {
            if (optionsMap.has(value))
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    exports.ZodDiscriminatedUnion = ZodDiscriminatedUnion;
    function mergeValues(a, b) {
      let aType = (0, util_1.getParsedType)(a), bType = (0, util_1.getParsedType)(b);
      if (a === b)
        return { valid: !0, data: a };
      if (aType === util_1.ZodParsedType.object && bType === util_1.ZodParsedType.object) {
        let bKeys = util_1.util.objectKeys(b), sharedKeys = util_1.util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1), newObj = { ...a, ...b };
        for (let key of sharedKeys) {
          let sharedValue = mergeValues(a[key], b[key]);
          if (!sharedValue.valid)
            return { valid: !1 };
          newObj[key] = sharedValue.data;
        }
        return { valid: !0, data: newObj };
      } else if (aType === util_1.ZodParsedType.array && bType === util_1.ZodParsedType.array) {
        if (a.length !== b.length)
          return { valid: !1 };
        let newArray = [];
        for (let index = 0; index < a.length; index++) {
          let itemA = a[index], itemB = b[index], sharedValue = mergeValues(itemA, itemB);
          if (!sharedValue.valid)
            return { valid: !1 };
          newArray.push(sharedValue.data);
        }
        return { valid: !0, data: newArray };
      } else
        return aType === util_1.ZodParsedType.date && bType === util_1.ZodParsedType.date && +a == +b ? { valid: !0, data: a } : { valid: !1 };
    }
    var ZodIntersection = class extends ZodType {
      _parse(input) {
        let { status, ctx } = this._processInputParams(input), handleParsed = (parsedLeft, parsedRight) => {
          if ((0, parseUtil_1.isAborted)(parsedLeft) || (0, parseUtil_1.isAborted)(parsedRight))
            return parseUtil_1.INVALID;
          let merged = mergeValues(parsedLeft.value, parsedRight.value);
          return merged.valid ? (((0, parseUtil_1.isDirty)(parsedLeft) || (0, parseUtil_1.isDirty)(parsedRight)) && status.dirty(), { status: status.value, value: merged.data }) : ((0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_intersection_types
          }), parseUtil_1.INVALID);
        };
        return ctx.common.async ? Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right)) : handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    };
    exports.ZodIntersection = ZodIntersection;
    ZodIntersection.create = (left, right, params) => new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
    var ZodTuple = class _ZodTuple extends ZodType {
      _parse(input) {
        let { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.array)
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.array,
            received: ctx.parsedType
          }), parseUtil_1.INVALID;
        if (ctx.data.length < this._def.items.length)
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
          }), parseUtil_1.INVALID;
        !this._def.rest && ctx.data.length > this._def.items.length && ((0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }), status.dirty());
        let items = [...ctx.data].map((item, itemIndex) => {
          let schema = this._def.items[itemIndex] || this._def.rest;
          return schema ? schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex)) : null;
        }).filter((x) => !!x);
        return ctx.common.async ? Promise.all(items).then((results) => parseUtil_1.ParseStatus.mergeArray(status, results)) : parseUtil_1.ParseStatus.mergeArray(status, items);
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    exports.ZodTuple = ZodTuple;
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas))
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    var ZodRecord = class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        let { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.object)
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.object,
            received: ctx.parsedType
          }), parseUtil_1.INVALID;
        let pairs = [], keyType = this._def.keyType, valueType = this._def.valueType;
        for (let key in ctx.data)
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
          });
        return ctx.common.async ? parseUtil_1.ParseStatus.mergeObjectAsync(status, pairs) : parseUtil_1.ParseStatus.mergeObjectSync(status, pairs);
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        return second instanceof ZodType ? new _ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        }) : new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    exports.ZodRecord = ZodRecord;
    var ZodMap = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        let { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.map)
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.map,
            received: ctx.parsedType
          }), parseUtil_1.INVALID;
        let keyType = this._def.keyType, valueType = this._def.valueType, pairs = [...ctx.data.entries()].map(([key, value], index) => ({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        }));
        if (ctx.common.async) {
          let finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (let pair of pairs) {
              let key = await pair.key, value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted")
                return parseUtil_1.INVALID;
              (key.status === "dirty" || value.status === "dirty") && status.dirty(), finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          let finalMap = /* @__PURE__ */ new Map();
          for (let pair of pairs) {
            let key = pair.key, value = pair.value;
            if (key.status === "aborted" || value.status === "aborted")
              return parseUtil_1.INVALID;
            (key.status === "dirty" || value.status === "dirty") && status.dirty(), finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    exports.ZodMap = ZodMap;
    ZodMap.create = (keyType, valueType, params) => new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
    var ZodSet = class _ZodSet extends ZodType {
      _parse(input) {
        let { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.set)
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.set,
            received: ctx.parsedType
          }), parseUtil_1.INVALID;
        let def = this._def;
        def.minSize !== null && ctx.data.size < def.minSize.value && ((0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: def.minSize.message
        }), status.dirty()), def.maxSize !== null && ctx.data.size > def.maxSize.value && ((0, parseUtil_1.addIssueToContext)(ctx, {
          code: ZodError_1.ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: def.maxSize.message
        }), status.dirty());
        let valueType = this._def.valueType;
        function finalizeSet(elements2) {
          let parsedSet = /* @__PURE__ */ new Set();
          for (let element of elements2) {
            if (element.status === "aborted")
              return parseUtil_1.INVALID;
            element.status === "dirty" && status.dirty(), parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        let elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        return ctx.common.async ? Promise.all(elements).then((elements2) => finalizeSet(elements2)) : finalizeSet(elements);
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil_1.errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    exports.ZodSet = ZodSet;
    ZodSet.create = (valueType, params) => new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
    var ZodFunction = class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments), this.validate = this.implement;
      }
      _parse(input) {
        let { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.function)
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.function,
            received: ctx.parsedType
          }), parseUtil_1.INVALID;
        function makeArgsIssue(args, error) {
          return (0, parseUtil_1.makeIssue)({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              (0, errors_1.getErrorMap)(),
              errors_1.defaultErrorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodError_1.ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        function makeReturnsIssue(returns, error) {
          return (0, parseUtil_1.makeIssue)({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              (0, errors_1.getErrorMap)(),
              errors_1.defaultErrorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodError_1.ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        let params = { errorMap: ctx.common.contextualErrorMap }, fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          let me = this;
          return (0, parseUtil_1.OK)(async function(...args) {
            let error = new ZodError_1.ZodError([]), parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              throw error.addIssue(makeArgsIssue(args, e)), error;
            }), result = await Reflect.apply(fn, this, parsedArgs);
            return await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              throw error.addIssue(makeReturnsIssue(result, e)), error;
            });
          });
        } else {
          let me = this;
          return (0, parseUtil_1.OK)(function(...args) {
            let parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success)
              throw new ZodError_1.ZodError([makeArgsIssue(args, parsedArgs.error)]);
            let result = Reflect.apply(fn, this, parsedArgs.data), parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success)
              throw new ZodError_1.ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        return this.parse(func);
      }
      strictImplement(func) {
        return this.parse(func);
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args || ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    exports.ZodFunction = ZodFunction;
    var ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        let { ctx } = this._processInputParams(input);
        return this._def.getter()._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    exports.ZodLazy = ZodLazy;
    ZodLazy.create = (getter, params) => new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
    var ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          let ctx = this._getOrReturnCtx(input);
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_literal,
            expected: this._def.value
          }), parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    exports.ZodLiteral = ZodLiteral;
    ZodLiteral.create = (value, params) => new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
    function createZodEnum(values, params) {
      return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params)
      });
    }
    var ZodEnum = class _ZodEnum extends ZodType {
      _parse(input) {
        if (typeof input.data != "string") {
          let ctx = this._getOrReturnCtx(input), expectedValues = this._def.values;
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            expected: util_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_1.ZodIssueCode.invalid_type
          }), parseUtil_1.INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
          let ctx = this._getOrReturnCtx(input), expectedValues = this._def.values;
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          }), parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        let enumValues = {};
        for (let val of this._def.values)
          enumValues[val] = val;
        return enumValues;
      }
      get Values() {
        let enumValues = {};
        for (let val of this._def.values)
          enumValues[val] = val;
        return enumValues;
      }
      get Enum() {
        let enumValues = {};
        for (let val of this._def.values)
          enumValues[val] = val;
        return enumValues;
      }
      extract(values) {
        return _ZodEnum.create(values);
      }
      exclude(values) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
      }
    };
    exports.ZodEnum = ZodEnum;
    ZodEnum.create = createZodEnum;
    var ZodNativeEnum = class extends ZodType {
      _parse(input) {
        let nativeEnumValues = util_1.util.getValidEnumValues(this._def.values), ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== util_1.ZodParsedType.string && ctx.parsedType !== util_1.ZodParsedType.number) {
          let expectedValues = util_1.util.objectValues(nativeEnumValues);
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            expected: util_1.util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodError_1.ZodIssueCode.invalid_type
          }), parseUtil_1.INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
          let expectedValues = util_1.util.objectValues(nativeEnumValues);
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            received: ctx.data,
            code: ZodError_1.ZodIssueCode.invalid_enum_value,
            options: expectedValues
          }), parseUtil_1.INVALID;
        }
        return (0, parseUtil_1.OK)(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    exports.ZodNativeEnum = ZodNativeEnum;
    ZodNativeEnum.create = (values, params) => new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
    var ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        let { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== util_1.ZodParsedType.promise && ctx.common.async === !1)
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.promise,
            received: ctx.parsedType
          }), parseUtil_1.INVALID;
        let promisified = ctx.parsedType === util_1.ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return (0, parseUtil_1.OK)(promisified.then((data) => this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        })));
      }
    };
    exports.ZodPromise = ZodPromise;
    ZodPromise.create = (schema, params) => new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
    var ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        let { status, ctx } = this._processInputParams(input), effect = this._def.effect || null, checkCtx = {
          addIssue: (arg) => {
            (0, parseUtil_1.addIssueToContext)(ctx, arg), arg.fatal ? status.abort() : status.dirty();
          },
          get path() {
            return ctx.path;
          }
        };
        if (checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx), effect.type === "preprocess") {
          let processed = effect.transform(ctx.data, checkCtx);
          return ctx.common.issues.length ? {
            status: "dirty",
            value: ctx.data
          } : ctx.common.async ? Promise.resolve(processed).then((processed2) => this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          })) : this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
        }
        if (effect.type === "refinement") {
          let executeRefinement = (acc) => {
            let result = effect.refinement(acc, checkCtx);
            if (ctx.common.async)
              return Promise.resolve(result);
            if (result instanceof Promise)
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            return acc;
          };
          if (ctx.common.async === !1) {
            let inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            return inner.status === "aborted" ? parseUtil_1.INVALID : (inner.status === "dirty" && status.dirty(), executeRefinement(inner.value), { status: status.value, value: inner.value });
          } else
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => inner.status === "aborted" ? parseUtil_1.INVALID : (inner.status === "dirty" && status.dirty(), executeRefinement(inner.value).then(() => ({ status: status.value, value: inner.value }))));
        }
        if (effect.type === "transform")
          if (ctx.common.async === !1) {
            let base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!(0, parseUtil_1.isValid)(base))
              return base;
            let result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise)
              throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
            return { status: status.value, value: result };
          } else
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => (0, parseUtil_1.isValid)(base) ? Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result })) : base);
        util_1.util.assertNever(effect);
      }
    };
    exports.ZodEffects = ZodEffects;
    exports.ZodTransformer = ZodEffects;
    ZodEffects.create = (schema, effect, params) => new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
    ZodEffects.createWithPreprocess = (preprocess, schema, params) => new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
    var ZodOptional = class extends ZodType {
      _parse(input) {
        return this._getType(input) === util_1.ZodParsedType.undefined ? (0, parseUtil_1.OK)(void 0) : this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports.ZodOptional = ZodOptional;
    ZodOptional.create = (type, params) => new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
    var ZodNullable = class extends ZodType {
      _parse(input) {
        return this._getType(input) === util_1.ZodParsedType.null ? (0, parseUtil_1.OK)(null) : this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    exports.ZodNullable = ZodNullable;
    ZodNullable.create = (type, params) => new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
    var ZodDefault = class extends ZodType {
      _parse(input) {
        let { ctx } = this._processInputParams(input), data = ctx.data;
        return ctx.parsedType === util_1.ZodParsedType.undefined && (data = this._def.defaultValue()), this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    exports.ZodDefault = ZodDefault;
    ZodDefault.create = (type, params) => new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default == "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
    var ZodCatch = class extends ZodType {
      _parse(input) {
        let { ctx } = this._processInputParams(input), newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        }, result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        return (0, parseUtil_1.isAsync)(result) ? result.then((result2) => ({
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError_1.ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        })) : {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError_1.ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    exports.ZodCatch = ZodCatch;
    ZodCatch.create = (type, params) => new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch == "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
    var ZodNaN = class extends ZodType {
      _parse(input) {
        if (this._getType(input) !== util_1.ZodParsedType.nan) {
          let ctx = this._getOrReturnCtx(input);
          return (0, parseUtil_1.addIssueToContext)(ctx, {
            code: ZodError_1.ZodIssueCode.invalid_type,
            expected: util_1.ZodParsedType.nan,
            received: ctx.parsedType
          }), parseUtil_1.INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    exports.ZodNaN = ZodNaN;
    ZodNaN.create = (params) => new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
    exports.BRAND = Symbol("zod_brand");
    var ZodBranded = class extends ZodType {
      _parse(input) {
        let { ctx } = this._processInputParams(input), data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    exports.ZodBranded = ZodBranded;
    var ZodPipeline = class _ZodPipeline extends ZodType {
      _parse(input) {
        let { status, ctx } = this._processInputParams(input);
        if (ctx.common.async)
          return (async () => {
            let inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            return inResult.status === "aborted" ? parseUtil_1.INVALID : inResult.status === "dirty" ? (status.dirty(), (0, parseUtil_1.DIRTY)(inResult.value)) : this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          })();
        {
          let inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          return inResult.status === "aborted" ? parseUtil_1.INVALID : inResult.status === "dirty" ? (status.dirty(), {
            status: "dirty",
            value: inResult.value
          }) : this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      static create(a, b) {
        return new _ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    exports.ZodPipeline = ZodPipeline;
    var ZodReadonly = class extends ZodType {
      _parse(input) {
        let result = this._def.innerType._parse(input);
        return (0, parseUtil_1.isValid)(result) && (result.value = Object.freeze(result.value)), result;
      }
    };
    exports.ZodReadonly = ZodReadonly;
    ZodReadonly.create = (type, params) => new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
    var custom = (check, params = {}, fatal) => check ? ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        let p = typeof params == "function" ? params(data) : typeof params == "string" ? { message: params } : params, _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : !0, p2 = typeof p == "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    }) : ZodAny.create();
    exports.custom = custom;
    exports.late = {
      object: ZodObject.lazycreate
    };
    var ZodFirstPartyTypeKind;
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2.ZodString = "ZodString", ZodFirstPartyTypeKind2.ZodNumber = "ZodNumber", ZodFirstPartyTypeKind2.ZodNaN = "ZodNaN", ZodFirstPartyTypeKind2.ZodBigInt = "ZodBigInt", ZodFirstPartyTypeKind2.ZodBoolean = "ZodBoolean", ZodFirstPartyTypeKind2.ZodDate = "ZodDate", ZodFirstPartyTypeKind2.ZodSymbol = "ZodSymbol", ZodFirstPartyTypeKind2.ZodUndefined = "ZodUndefined", ZodFirstPartyTypeKind2.ZodNull = "ZodNull", ZodFirstPartyTypeKind2.ZodAny = "ZodAny", ZodFirstPartyTypeKind2.ZodUnknown = "ZodUnknown", ZodFirstPartyTypeKind2.ZodNever = "ZodNever", ZodFirstPartyTypeKind2.ZodVoid = "ZodVoid", ZodFirstPartyTypeKind2.ZodArray = "ZodArray", ZodFirstPartyTypeKind2.ZodObject = "ZodObject", ZodFirstPartyTypeKind2.ZodUnion = "ZodUnion", ZodFirstPartyTypeKind2.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", ZodFirstPartyTypeKind2.ZodIntersection = "ZodIntersection", ZodFirstPartyTypeKind2.ZodTuple = "ZodTuple", ZodFirstPartyTypeKind2.ZodRecord = "ZodRecord", ZodFirstPartyTypeKind2.ZodMap = "ZodMap", ZodFirstPartyTypeKind2.ZodSet = "ZodSet", ZodFirstPartyTypeKind2.ZodFunction = "ZodFunction", ZodFirstPartyTypeKind2.ZodLazy = "ZodLazy", ZodFirstPartyTypeKind2.ZodLiteral = "ZodLiteral", ZodFirstPartyTypeKind2.ZodEnum = "ZodEnum", ZodFirstPartyTypeKind2.ZodEffects = "ZodEffects", ZodFirstPartyTypeKind2.ZodNativeEnum = "ZodNativeEnum", ZodFirstPartyTypeKind2.ZodOptional = "ZodOptional", ZodFirstPartyTypeKind2.ZodNullable = "ZodNullable", ZodFirstPartyTypeKind2.ZodDefault = "ZodDefault", ZodFirstPartyTypeKind2.ZodCatch = "ZodCatch", ZodFirstPartyTypeKind2.ZodPromise = "ZodPromise", ZodFirstPartyTypeKind2.ZodBranded = "ZodBranded", ZodFirstPartyTypeKind2.ZodPipeline = "ZodPipeline", ZodFirstPartyTypeKind2.ZodReadonly = "ZodReadonly";
    })(ZodFirstPartyTypeKind = exports.ZodFirstPartyTypeKind || (exports.ZodFirstPartyTypeKind = {}));
    var instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => (0, exports.custom)((data) => data instanceof cls, params);
    exports.instanceof = instanceOfType;
    var stringType = ZodString.create;
    exports.string = stringType;
    var numberType = ZodNumber.create;
    exports.number = numberType;
    var nanType = ZodNaN.create;
    exports.nan = nanType;
    var bigIntType = ZodBigInt.create;
    exports.bigint = bigIntType;
    var booleanType = ZodBoolean.create;
    exports.boolean = booleanType;
    var dateType = ZodDate.create;
    exports.date = dateType;
    var symbolType = ZodSymbol.create;
    exports.symbol = symbolType;
    var undefinedType = ZodUndefined.create;
    exports.undefined = undefinedType;
    var nullType = ZodNull.create;
    exports.null = nullType;
    var anyType = ZodAny.create;
    exports.any = anyType;
    var unknownType = ZodUnknown.create;
    exports.unknown = unknownType;
    var neverType = ZodNever.create;
    exports.never = neverType;
    var voidType = ZodVoid.create;
    exports.void = voidType;
    var arrayType = ZodArray.create;
    exports.array = arrayType;
    var objectType = ZodObject.create;
    exports.object = objectType;
    var strictObjectType = ZodObject.strictCreate;
    exports.strictObject = strictObjectType;
    var unionType = ZodUnion.create;
    exports.union = unionType;
    var discriminatedUnionType = ZodDiscriminatedUnion.create;
    exports.discriminatedUnion = discriminatedUnionType;
    var intersectionType = ZodIntersection.create;
    exports.intersection = intersectionType;
    var tupleType = ZodTuple.create;
    exports.tuple = tupleType;
    var recordType = ZodRecord.create;
    exports.record = recordType;
    var mapType = ZodMap.create;
    exports.map = mapType;
    var setType = ZodSet.create;
    exports.set = setType;
    var functionType = ZodFunction.create;
    exports.function = functionType;
    var lazyType = ZodLazy.create;
    exports.lazy = lazyType;
    var literalType = ZodLiteral.create;
    exports.literal = literalType;
    var enumType = ZodEnum.create;
    exports.enum = enumType;
    var nativeEnumType = ZodNativeEnum.create;
    exports.nativeEnum = nativeEnumType;
    var promiseType = ZodPromise.create;
    exports.promise = promiseType;
    var effectsType = ZodEffects.create;
    exports.effect = effectsType;
    exports.transformer = effectsType;
    var optionalType = ZodOptional.create;
    exports.optional = optionalType;
    var nullableType = ZodNullable.create;
    exports.nullable = nullableType;
    var preprocessType = ZodEffects.createWithPreprocess;
    exports.preprocess = preprocessType;
    var pipelineType = ZodPipeline.create;
    exports.pipeline = pipelineType;
    var ostring = () => stringType().optional();
    exports.ostring = ostring;
    var onumber = () => numberType().optional();
    exports.onumber = onumber;
    var oboolean = () => booleanType().optional();
    exports.oboolean = oboolean;
    exports.coerce = {
      string: (arg) => ZodString.create({ ...arg, coerce: !0 }),
      number: (arg) => ZodNumber.create({ ...arg, coerce: !0 }),
      boolean: (arg) => ZodBoolean.create({
        ...arg,
        coerce: !0
      }),
      bigint: (arg) => ZodBigInt.create({ ...arg, coerce: !0 }),
      date: (arg) => ZodDate.create({ ...arg, coerce: !0 })
    };
    exports.NEVER = parseUtil_1.INVALID;
  }
});

// ../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/external.js
var require_external = __commonJS({
  "../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/external.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    __exportStar(require_errors(), exports);
    __exportStar(require_parseUtil(), exports);
    __exportStar(require_typeAliases(), exports);
    __exportStar(require_util(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_ZodError(), exports);
  }
});

// ../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/zod@3.22.3/node_modules/zod/lib/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), Object.defineProperty(o, k2, { enumerable: !0, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      k2 === void 0 && (k2 = k), o[k2] = m[k];
    }), __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: !0, value: v });
    } : function(o, v) {
      o.default = v;
    }), __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null)
        for (var k in mod)
          k !== "default" && Object.prototype.hasOwnProperty.call(mod, k) && __createBinding(result, mod, k);
      return __setModuleDefault(result, mod), result;
    }, __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p) && __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.z = void 0;
    var z = __importStar(require_external());
    exports.z = z;
    __exportStar(require_external(), exports);
    exports.default = z;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/any.js
var require_any = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/any.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseAnyDef = void 0;
    function parseAnyDef() {
      return {};
    }
    exports.parseAnyDef = parseAnyDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/errorMessages.js
var require_errorMessages = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/errorMessages.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.setResponseValueAndErrors = exports.addErrorMessage = void 0;
    function addErrorMessage(res, key, errorMessage, refs) {
      refs?.errorMessages && errorMessage && (res.errorMessage = Object.assign(Object.assign({}, res.errorMessage), { [key]: errorMessage }));
    }
    exports.addErrorMessage = addErrorMessage;
    function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
      res[key] = value, addErrorMessage(res, key, errorMessage, refs);
    }
    exports.setResponseValueAndErrors = setResponseValueAndErrors;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/array.js
var require_array = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/array.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseArrayDef = void 0;
    var zod_1 = require_lib(), errorMessages_1 = require_errorMessages(), parseDef_1 = require_parseDef();
    function parseArrayDef(def, refs) {
      var _a, _b;
      let res = {
        type: "array"
      };
      return ((_b = (_a = def.type) === null || _a === void 0 ? void 0 : _a._def) === null || _b === void 0 ? void 0 : _b.typeName) !== zod_1.ZodFirstPartyTypeKind.ZodAny && (res.items = (0, parseDef_1.parseDef)(def.type._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "items"] }))), def.minLength && (0, errorMessages_1.setResponseValueAndErrors)(res, "minItems", def.minLength.value, def.minLength.message, refs), def.maxLength && (0, errorMessages_1.setResponseValueAndErrors)(res, "maxItems", def.maxLength.value, def.maxLength.message, refs), def.exactLength && ((0, errorMessages_1.setResponseValueAndErrors)(res, "minItems", def.exactLength.value, def.exactLength.message, refs), (0, errorMessages_1.setResponseValueAndErrors)(res, "maxItems", def.exactLength.value, def.exactLength.message, refs)), res;
    }
    exports.parseArrayDef = parseArrayDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/bigint.js
var require_bigint = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/bigint.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseBigintDef = void 0;
    var errorMessages_1 = require_errorMessages();
    function parseBigintDef(def, refs) {
      let res = {
        type: "integer",
        format: "int64"
      };
      if (!def.checks)
        return res;
      for (let check of def.checks)
        switch (check.kind) {
          case "min":
            refs.target === "jsonSchema7" ? check.inclusive ? (0, errorMessages_1.setResponseValueAndErrors)(res, "minimum", check.value, check.message, refs) : (0, errorMessages_1.setResponseValueAndErrors)(res, "exclusiveMinimum", check.value, check.message, refs) : (check.inclusive || (res.exclusiveMinimum = !0), (0, errorMessages_1.setResponseValueAndErrors)(res, "minimum", check.value, check.message, refs));
            break;
          case "max":
            refs.target === "jsonSchema7" ? check.inclusive ? (0, errorMessages_1.setResponseValueAndErrors)(res, "maximum", check.value, check.message, refs) : (0, errorMessages_1.setResponseValueAndErrors)(res, "exclusiveMaximum", check.value, check.message, refs) : (check.inclusive || (res.exclusiveMaximum = !0), (0, errorMessages_1.setResponseValueAndErrors)(res, "maximum", check.value, check.message, refs));
            break;
          case "multipleOf":
            (0, errorMessages_1.setResponseValueAndErrors)(res, "multipleOf", check.value, check.message, refs);
            break;
        }
      return res;
    }
    exports.parseBigintDef = parseBigintDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/boolean.js
var require_boolean = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/boolean.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseBooleanDef = void 0;
    function parseBooleanDef() {
      return {
        type: "boolean"
      };
    }
    exports.parseBooleanDef = parseBooleanDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/branded.js
var require_branded = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/branded.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseBrandedDef = void 0;
    var parseDef_1 = require_parseDef();
    function parseBrandedDef(_def, refs) {
      return (0, parseDef_1.parseDef)(_def.type._def, refs);
    }
    exports.parseBrandedDef = parseBrandedDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/catch.js
var require_catch = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/catch.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseCatchDef = void 0;
    var parseDef_1 = require_parseDef(), parseCatchDef = (def, refs) => (0, parseDef_1.parseDef)(def.innerType._def, refs);
    exports.parseCatchDef = parseCatchDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/date.js
var require_date = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/date.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseDateDef = void 0;
    var errorMessages_1 = require_errorMessages();
    function parseDateDef(def, refs) {
      return refs.dateStrategy == "integer" ? integerDateParser(def, refs) : {
        type: "string",
        format: "date-time"
      };
    }
    exports.parseDateDef = parseDateDef;
    var integerDateParser = (def, refs) => {
      let res = {
        type: "integer",
        format: "unix-time"
      };
      for (let check of def.checks)
        switch (check.kind) {
          case "min":
            refs.target === "jsonSchema7" && (0, errorMessages_1.setResponseValueAndErrors)(
              res,
              "minimum",
              check.value,
              // This is in milliseconds
              check.message,
              refs
            );
            break;
          case "max":
            refs.target === "jsonSchema7" && (0, errorMessages_1.setResponseValueAndErrors)(
              res,
              "maximum",
              check.value,
              // This is in milliseconds
              check.message,
              refs
            );
            break;
        }
      return res;
    };
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/default.js
var require_default = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/default.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseDefaultDef = void 0;
    var parseDef_1 = require_parseDef();
    function parseDefaultDef(_def, refs) {
      return Object.assign(Object.assign({}, (0, parseDef_1.parseDef)(_def.innerType._def, refs)), { default: _def.defaultValue() });
    }
    exports.parseDefaultDef = parseDefaultDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/effects.js
var require_effects = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/effects.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseEffectsDef = void 0;
    var parseDef_1 = require_parseDef();
    function parseEffectsDef(_def, refs) {
      return refs.effectStrategy === "input" ? (0, parseDef_1.parseDef)(_def.schema._def, refs) : {};
    }
    exports.parseEffectsDef = parseEffectsDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/enum.js
var require_enum = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/enum.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseEnumDef = void 0;
    function parseEnumDef(def) {
      return {
        type: "string",
        enum: def.values
      };
    }
    exports.parseEnumDef = parseEnumDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/intersection.js
var require_intersection = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/intersection.js"(exports) {
    "use strict";
    init_cjs_shims();
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
      if (s != null && typeof Object.getOwnPropertySymbols == "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++)
          e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseIntersectionDef = void 0;
    var parseDef_1 = require_parseDef(), isJsonSchema7AllOfType = (type) => "type" in type && type.type === "string" ? !1 : "allOf" in type;
    function parseIntersectionDef(def, refs) {
      let allOf = [
        (0, parseDef_1.parseDef)(def.left._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "allOf", "0"] })),
        (0, parseDef_1.parseDef)(def.right._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "allOf", "1"] }))
      ].filter((x) => !!x), unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0, mergedAllOf = [];
      return allOf.forEach((schema) => {
        if (isJsonSchema7AllOfType(schema))
          mergedAllOf.push(...schema.allOf), schema.unevaluatedProperties === void 0 && (unevaluatedProperties = void 0);
        else {
          let nestedSchema = schema;
          if ("additionalProperties" in schema && schema.additionalProperties === !1) {
            let { additionalProperties } = schema;
            nestedSchema = __rest(schema, ["additionalProperties"]);
          } else
            unevaluatedProperties = void 0;
          mergedAllOf.push(nestedSchema);
        }
      }), mergedAllOf.length ? Object.assign({ allOf: mergedAllOf }, unevaluatedProperties) : void 0;
    }
    exports.parseIntersectionDef = parseIntersectionDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/literal.js
var require_literal = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/literal.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseLiteralDef = void 0;
    function parseLiteralDef(def, refs) {
      let parsedType = typeof def.value;
      return parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string" ? {
        type: Array.isArray(def.value) ? "array" : "object"
      } : refs.target === "openApi3" ? {
        type: parsedType === "bigint" ? "integer" : parsedType,
        enum: [def.value]
      } : {
        type: parsedType === "bigint" ? "integer" : parsedType,
        const: def.value
      };
    }
    exports.parseLiteralDef = parseLiteralDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/map.js
var require_map = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/map.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseMapDef = void 0;
    var parseDef_1 = require_parseDef();
    function parseMapDef(def, refs) {
      let keys = (0, parseDef_1.parseDef)(def.keyType._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "items", "items", "0"] })) || {}, values = (0, parseDef_1.parseDef)(def.valueType._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "items", "items", "1"] })) || {};
      return {
        type: "array",
        maxItems: 125,
        items: {
          type: "array",
          items: [keys, values],
          minItems: 2,
          maxItems: 2
        }
      };
    }
    exports.parseMapDef = parseMapDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/nativeEnum.js
var require_nativeEnum = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/nativeEnum.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseNativeEnumDef = void 0;
    function parseNativeEnumDef(def) {
      let object = def.values, actualValues = Object.keys(def.values).filter((key) => typeof object[object[key]] != "number").map((key) => object[key]), parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
      return {
        type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
        enum: actualValues
      };
    }
    exports.parseNativeEnumDef = parseNativeEnumDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/never.js
var require_never = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/never.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseNeverDef = void 0;
    function parseNeverDef() {
      return {
        not: {}
      };
    }
    exports.parseNeverDef = parseNeverDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/null.js
var require_null = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/null.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseNullDef = void 0;
    function parseNullDef(refs) {
      return refs.target === "openApi3" ? {
        enum: ["null"],
        nullable: !0
      } : {
        type: "null"
      };
    }
    exports.parseNullDef = parseNullDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/union.js
var require_union = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/union.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseUnionDef = exports.primitiveMappings = void 0;
    var parseDef_1 = require_parseDef();
    exports.primitiveMappings = {
      ZodString: "string",
      ZodNumber: "number",
      ZodBigInt: "integer",
      ZodBoolean: "boolean",
      ZodNull: "null"
    };
    function parseUnionDef(def, refs) {
      if (refs.target === "openApi3")
        return asAnyOf(def, refs);
      let options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
      if (options.every((x) => x._def.typeName in exports.primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
        let types = options.reduce((types2, x) => {
          let type = exports.primitiveMappings[x._def.typeName];
          return type && !types2.includes(type) ? [...types2, type] : types2;
        }, []);
        return {
          type: types.length > 1 ? types : types[0]
        };
      } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
        let types = options.reduce((acc, x) => {
          let type = typeof x._def.value;
          switch (type) {
            case "string":
            case "number":
            case "boolean":
              return [...acc, type];
            case "bigint":
              return [...acc, "integer"];
            case "object":
              if (x._def.value === null)
                return [...acc, "null"];
            case "symbol":
            case "undefined":
            case "function":
            default:
              return acc;
          }
        }, []);
        if (types.length === options.length) {
          let uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
          return {
            type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
            enum: options.reduce((acc, x) => acc.includes(x._def.value) ? acc : [...acc, x._def.value], [])
          };
        }
      } else if (options.every((x) => x._def.typeName === "ZodEnum"))
        return {
          type: "string",
          enum: options.reduce((acc, x) => [
            ...acc,
            ...x._def.values.filter((x2) => !acc.includes(x2))
          ], [])
        };
      return asAnyOf(def, refs);
    }
    exports.parseUnionDef = parseUnionDef;
    var asAnyOf = (def, refs) => {
      let anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => (0, parseDef_1.parseDef)(x._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "anyOf", `${i}`] }))).filter((x) => !!x && (!refs.strictUnions || typeof x == "object" && Object.keys(x).length > 0));
      return anyOf.length ? { anyOf } : void 0;
    };
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/nullable.js
var require_nullable = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/nullable.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseNullableDef = void 0;
    var parseDef_1 = require_parseDef(), union_1 = require_union();
    function parseNullableDef(def, refs) {
      if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length))
        return refs.target === "openApi3" ? {
          type: union_1.primitiveMappings[def.innerType._def.typeName],
          nullable: !0
        } : {
          type: [
            union_1.primitiveMappings[def.innerType._def.typeName],
            "null"
          ]
        };
      if (refs.target === "openApi3") {
        let base2 = (0, parseDef_1.parseDef)(def.innerType._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath] }));
        return base2 && Object.assign(Object.assign({}, base2), { nullable: !0 });
      }
      let base = (0, parseDef_1.parseDef)(def.innerType._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "anyOf", "0"] }));
      return base && { anyOf: [base, { type: "null" }] };
    }
    exports.parseNullableDef = parseNullableDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/number.js
var require_number = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/number.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseNumberDef = void 0;
    var errorMessages_1 = require_errorMessages();
    function parseNumberDef(def, refs) {
      let res = {
        type: "number"
      };
      if (!def.checks)
        return res;
      for (let check of def.checks)
        switch (check.kind) {
          case "int":
            res.type = "integer", (0, errorMessages_1.addErrorMessage)(res, "type", check.message, refs);
            break;
          case "min":
            refs.target === "jsonSchema7" ? check.inclusive ? (0, errorMessages_1.setResponseValueAndErrors)(res, "minimum", check.value, check.message, refs) : (0, errorMessages_1.setResponseValueAndErrors)(res, "exclusiveMinimum", check.value, check.message, refs) : (check.inclusive || (res.exclusiveMinimum = !0), (0, errorMessages_1.setResponseValueAndErrors)(res, "minimum", check.value, check.message, refs));
            break;
          case "max":
            refs.target === "jsonSchema7" ? check.inclusive ? (0, errorMessages_1.setResponseValueAndErrors)(res, "maximum", check.value, check.message, refs) : (0, errorMessages_1.setResponseValueAndErrors)(res, "exclusiveMaximum", check.value, check.message, refs) : (check.inclusive || (res.exclusiveMaximum = !0), (0, errorMessages_1.setResponseValueAndErrors)(res, "maximum", check.value, check.message, refs));
            break;
          case "multipleOf":
            (0, errorMessages_1.setResponseValueAndErrors)(res, "multipleOf", check.value, check.message, refs);
            break;
        }
      return res;
    }
    exports.parseNumberDef = parseNumberDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/object.js
var require_object = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/object.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseObjectDef = exports.parseObjectDefX = void 0;
    var parseDef_1 = require_parseDef();
    function parseObjectDefX(def, refs) {
      var _a, _b;
      Object.keys(def.shape()).reduce((schema, key) => {
        let prop = def.shape()[key], isOptional = prop.isOptional();
        isOptional || (prop = Object.assign({}, prop._def.innerSchema));
        let propSchema = (0, parseDef_1.parseDef)(prop._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "properties", key], propertyPath: [...refs.currentPath, "properties", key] }));
        return propSchema !== void 0 && (schema.properties[key] = propSchema, isOptional || (schema.required || (schema.required = []), schema.required.push(key))), schema;
      }, {
        type: "object",
        properties: {},
        additionalProperties: def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : (_a = (0, parseDef_1.parseDef)(def.catchall._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "additionalProperties"] }))) !== null && _a !== void 0 ? _a : !0
      });
      let result = Object.assign(Object.assign({ type: "object" }, Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {
        if (propDef === void 0 || propDef._def === void 0)
          return acc;
        let parsedDef = (0, parseDef_1.parseDef)(propDef._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "properties", propName], propertyPath: [...refs.currentPath, "properties", propName] }));
        return parsedDef === void 0 ? acc : {
          properties: Object.assign(Object.assign({}, acc.properties), { [propName]: parsedDef }),
          required: propDef.isOptional() ? acc.required : [...acc.required, propName]
        };
      }, { properties: {}, required: [] })), { additionalProperties: def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : (_b = (0, parseDef_1.parseDef)(def.catchall._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "additionalProperties"] }))) !== null && _b !== void 0 ? _b : !0 });
      return result.required.length || delete result.required, result;
    }
    exports.parseObjectDefX = parseObjectDefX;
    function parseObjectDef(def, refs) {
      var _a;
      let result = Object.assign(Object.assign({ type: "object" }, Object.entries(def.shape()).reduce((acc, [propName, propDef]) => {
        if (propDef === void 0 || propDef._def === void 0)
          return acc;
        let parsedDef = (0, parseDef_1.parseDef)(propDef._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "properties", propName], propertyPath: [...refs.currentPath, "properties", propName] }));
        return parsedDef === void 0 ? acc : {
          properties: Object.assign(Object.assign({}, acc.properties), { [propName]: parsedDef }),
          required: propDef.isOptional() ? acc.required : [...acc.required, propName]
        };
      }, { properties: {}, required: [] })), { additionalProperties: def.catchall._def.typeName === "ZodNever" ? def.unknownKeys === "passthrough" : (_a = (0, parseDef_1.parseDef)(def.catchall._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "additionalProperties"] }))) !== null && _a !== void 0 ? _a : !0 });
      return result.required.length || delete result.required, result;
    }
    exports.parseObjectDef = parseObjectDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/optional.js
var require_optional = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/optional.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseOptionalDef = void 0;
    var parseDef_1 = require_parseDef(), parseOptionalDef = (def, refs) => {
      var _a;
      if (refs.currentPath.toString() === ((_a = refs.propertyPath) === null || _a === void 0 ? void 0 : _a.toString()))
        return (0, parseDef_1.parseDef)(def.innerType._def, refs);
      let innerSchema = (0, parseDef_1.parseDef)(def.innerType._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "anyOf", "1"] }));
      return innerSchema ? {
        anyOf: [
          {
            not: {}
          },
          innerSchema
        ]
      } : {};
    };
    exports.parseOptionalDef = parseOptionalDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/pipeline.js
var require_pipeline = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/pipeline.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parsePipelineDef = void 0;
    var parseDef_1 = require_parseDef(), parsePipelineDef = (def, refs) => {
      if (refs.pipeStrategy === "input")
        return (0, parseDef_1.parseDef)(def.in._def, refs);
      let a = (0, parseDef_1.parseDef)(def.in._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "allOf", "0"] })), b = (0, parseDef_1.parseDef)(def.out._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"] }));
      return {
        allOf: [a, b].filter((x) => x !== void 0)
      };
    };
    exports.parsePipelineDef = parsePipelineDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/promise.js
var require_promise = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/promise.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parsePromiseDef = void 0;
    var parseDef_1 = require_parseDef();
    function parsePromiseDef(def, refs) {
      return (0, parseDef_1.parseDef)(def.type._def, refs);
    }
    exports.parsePromiseDef = parsePromiseDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/string.js
var require_string = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/string.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseStringDef = exports.emojiPattern = exports.ulidPattern = exports.cuid2Pattern = exports.cuidPattern = exports.emailPattern = void 0;
    var errorMessages_1 = require_errorMessages();
    exports.emailPattern = '^(([^<>()[\\]\\\\.,;:\\s@\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\"]+)*)|(\\".+\\"))@((\\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\])|(\\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\\.[A-Za-z]{2,})+))$';
    exports.cuidPattern = "^c[^\\s-]{8,}$";
    exports.cuid2Pattern = "^[a-z][a-z0-9]*$";
    exports.ulidPattern = "/[0-9A-HJKMNP-TV-Z]{26}/";
    exports.emojiPattern = "/^(p{Extended_Pictographic}|p{Emoji_Component})+$/u";
    function parseStringDef(def, refs) {
      let res = {
        type: "string"
      };
      if (def.checks)
        for (let check of def.checks)
          switch (check.kind) {
            case "min":
              (0, errorMessages_1.setResponseValueAndErrors)(res, "minLength", typeof res.minLength == "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);
              break;
            case "max":
              (0, errorMessages_1.setResponseValueAndErrors)(res, "maxLength", typeof res.maxLength == "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
              break;
            case "email":
              switch (refs.emailStrategy) {
                case "format:email":
                  addFormat(res, "email", check.message, refs);
                  break;
                case "format:idn-email":
                  addFormat(res, "idn-email", check.message, refs);
                  break;
                case "pattern:zod":
                  addPattern(res, exports.emailPattern, check.message, refs);
                  break;
              }
              break;
            case "url":
              addFormat(res, "uri", check.message, refs);
              break;
            case "uuid":
              addFormat(res, "uuid", check.message, refs);
              break;
            case "regex":
              addPattern(res, check.regex.source, check.message, refs);
              break;
            case "cuid":
              addPattern(res, exports.cuidPattern, check.message, refs);
              break;
            case "cuid2":
              addPattern(res, exports.cuid2Pattern, check.message, refs);
              break;
            case "startsWith":
              addPattern(res, "^" + escapeNonAlphaNumeric(check.value), check.message, refs);
              break;
            case "endsWith":
              addPattern(res, escapeNonAlphaNumeric(check.value) + "$", check.message, refs);
              break;
            case "datetime":
              addFormat(res, "date-time", check.message, refs);
              break;
            case "length":
              (0, errorMessages_1.setResponseValueAndErrors)(res, "minLength", typeof res.minLength == "number" ? Math.max(res.minLength, check.value) : check.value, check.message, refs), (0, errorMessages_1.setResponseValueAndErrors)(res, "maxLength", typeof res.maxLength == "number" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);
              break;
            case "includes": {
              addPattern(res, escapeNonAlphaNumeric(check.value), check.message, refs);
              break;
            }
            case "ip": {
              check.version !== "v6" && addFormat(res, "ipv4", check.message, refs), check.version !== "v4" && addFormat(res, "ipv6", check.message, refs);
              break;
            }
            case "emoji":
              addPattern(res, exports.emojiPattern, check.message, refs);
              break;
            case "ulid": {
              addPattern(res, exports.ulidPattern, check.message, refs);
              break;
            }
            case "toLowerCase":
            case "toUpperCase":
            case "trim":
              break;
            default:
          }
      return res;
    }
    exports.parseStringDef = parseStringDef;
    var escapeNonAlphaNumeric = (value) => Array.from(value).map((c) => /[a-zA-Z0-9]/.test(c) ? c : `\\${c}`).join(""), addFormat = (schema, value, message, refs) => {
      var _a;
      schema.format || !((_a = schema.anyOf) === null || _a === void 0) && _a.some((x) => x.format) ? (schema.anyOf || (schema.anyOf = []), schema.format && (schema.anyOf.push(Object.assign({ format: schema.format }, schema.errorMessage && refs.errorMessages && {
        errorMessage: { format: schema.errorMessage.format }
      })), delete schema.format, schema.errorMessage && (delete schema.errorMessage.format, Object.keys(schema.errorMessage).length === 0 && delete schema.errorMessage)), schema.anyOf.push(Object.assign({ format: value }, message && refs.errorMessages && { errorMessage: { format: message } }))) : (0, errorMessages_1.setResponseValueAndErrors)(schema, "format", value, message, refs);
    }, addPattern = (schema, value, message, refs) => {
      var _a;
      schema.pattern || !((_a = schema.allOf) === null || _a === void 0) && _a.some((x) => x.pattern) ? (schema.allOf || (schema.allOf = []), schema.pattern && (schema.allOf.push(Object.assign({ pattern: schema.pattern }, schema.errorMessage && refs.errorMessages && {
        errorMessage: { pattern: schema.errorMessage.pattern }
      })), delete schema.pattern, schema.errorMessage && (delete schema.errorMessage.pattern, Object.keys(schema.errorMessage).length === 0 && delete schema.errorMessage)), schema.allOf.push(Object.assign({ pattern: value }, message && refs.errorMessages && { errorMessage: { pattern: message } }))) : (0, errorMessages_1.setResponseValueAndErrors)(schema, "pattern", value, message, refs);
    };
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/record.js
var require_record = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/record.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseRecordDef = void 0;
    var zod_1 = require_lib(), parseDef_1 = require_parseDef(), string_1 = require_string();
    function parseRecordDef(def, refs) {
      var _a, _b, _c, _d, _e;
      if (refs.target === "openApi3" && ((_a = def.keyType) === null || _a === void 0 ? void 0 : _a._def.typeName) === zod_1.ZodFirstPartyTypeKind.ZodEnum)
        return {
          type: "object",
          required: def.keyType._def.values,
          properties: def.keyType._def.values.reduce((acc, key) => {
            var _a2;
            return Object.assign(Object.assign({}, acc), { [key]: (_a2 = (0, parseDef_1.parseDef)(def.valueType._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "properties", key] }))) !== null && _a2 !== void 0 ? _a2 : {} });
          }, {}),
          additionalProperties: !1
        };
      let schema = {
        type: "object",
        additionalProperties: (_b = (0, parseDef_1.parseDef)(def.valueType._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "additionalProperties"] }))) !== null && _b !== void 0 ? _b : {}
      };
      if (refs.target === "openApi3")
        return schema;
      if (((_c = def.keyType) === null || _c === void 0 ? void 0 : _c._def.typeName) === zod_1.ZodFirstPartyTypeKind.ZodString && (!((_d = def.keyType._def.checks) === null || _d === void 0) && _d.length)) {
        let keyType = Object.entries((0, string_1.parseStringDef)(def.keyType._def, refs)).reduce((acc, [key, value]) => key === "type" ? acc : Object.assign(Object.assign({}, acc), { [key]: value }), {});
        return Object.assign(Object.assign({}, schema), { propertyNames: keyType });
      } else if (((_e = def.keyType) === null || _e === void 0 ? void 0 : _e._def.typeName) === zod_1.ZodFirstPartyTypeKind.ZodEnum)
        return Object.assign(Object.assign({}, schema), { propertyNames: {
          enum: def.keyType._def.values
        } });
      return schema;
    }
    exports.parseRecordDef = parseRecordDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/set.js
var require_set = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/set.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseSetDef = void 0;
    var errorMessages_1 = require_errorMessages(), parseDef_1 = require_parseDef();
    function parseSetDef(def, refs) {
      let schema = {
        type: "array",
        uniqueItems: !0,
        items: (0, parseDef_1.parseDef)(def.valueType._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "items"] }))
      };
      return def.minSize && (0, errorMessages_1.setResponseValueAndErrors)(schema, "minItems", def.minSize.value, def.minSize.message, refs), def.maxSize && (0, errorMessages_1.setResponseValueAndErrors)(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs), schema;
    }
    exports.parseSetDef = parseSetDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/tuple.js
var require_tuple = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/tuple.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseTupleDef = void 0;
    var parseDef_1 = require_parseDef();
    function parseTupleDef(def, refs) {
      return def.rest ? {
        type: "array",
        minItems: def.items.length,
        items: def.items.map((x, i) => (0, parseDef_1.parseDef)(x._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "items", `${i}`] }))).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
        additionalItems: (0, parseDef_1.parseDef)(def.rest._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "additionalItems"] }))
      } : {
        type: "array",
        minItems: def.items.length,
        maxItems: def.items.length,
        items: def.items.map((x, i) => (0, parseDef_1.parseDef)(x._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.currentPath, "items", `${i}`] }))).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
      };
    }
    exports.parseTupleDef = parseTupleDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/undefined.js
var require_undefined = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/undefined.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseUndefinedDef = void 0;
    function parseUndefinedDef() {
      return {
        not: {}
      };
    }
    exports.parseUndefinedDef = parseUndefinedDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/unknown.js
var require_unknown = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parsers/unknown.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseUnknownDef = void 0;
    function parseUnknownDef() {
      return {};
    }
    exports.parseUnknownDef = parseUnknownDef;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parseDef.js
var require_parseDef = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/parseDef.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.parseDef = void 0;
    var zod_1 = require_lib(), any_1 = require_any(), array_1 = require_array(), bigint_1 = require_bigint(), boolean_1 = require_boolean(), branded_1 = require_branded(), catch_1 = require_catch(), date_1 = require_date(), default_1 = require_default(), effects_1 = require_effects(), enum_1 = require_enum(), intersection_1 = require_intersection(), literal_1 = require_literal(), map_1 = require_map(), nativeEnum_1 = require_nativeEnum(), never_1 = require_never(), null_1 = require_null(), nullable_1 = require_nullable(), number_1 = require_number(), object_1 = require_object(), optional_1 = require_optional(), pipeline_1 = require_pipeline(), promise_1 = require_promise(), record_1 = require_record(), set_1 = require_set(), string_1 = require_string(), tuple_1 = require_tuple(), undefined_1 = require_undefined(), union_1 = require_union(), unknown_1 = require_unknown();
    function parseDef(def, refs, forceResolution = !1) {
      let seenItem = refs.seen.get(def);
      if (seenItem && !forceResolution) {
        let seenSchema = get$ref(seenItem, refs);
        if (seenSchema !== void 0)
          return seenSchema;
      }
      let newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
      refs.seen.set(def, newItem);
      let jsonSchema = selectParser(def, def.typeName, refs);
      return jsonSchema && addMeta(def, refs, jsonSchema), newItem.jsonSchema = jsonSchema, jsonSchema;
    }
    exports.parseDef = parseDef;
    var get$ref = (item, refs) => {
      switch (refs.$refStrategy) {
        case "root":
          return {
            $ref: item.path.length === 0 ? "" : item.path.length === 1 ? `${item.path[0]}/` : item.path.join("/")
          };
        case "relative":
          return { $ref: getRelativePath(refs.currentPath, item.path) };
        case "none":
          return item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value) ? (console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`), {}) : void 0;
        case "seen":
          return item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value) ? (console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`), {}) : item.jsonSchema;
      }
    }, getRelativePath = (pathA, pathB) => {
      let i = 0;
      for (; i < pathA.length && i < pathB.length && pathA[i] === pathB[i]; i++)
        ;
      return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
    }, selectParser = (def, typeName, refs) => {
      switch (typeName) {
        case zod_1.ZodFirstPartyTypeKind.ZodString:
          return (0, string_1.parseStringDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodNumber:
          return (0, number_1.parseNumberDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodObject:
          return (0, object_1.parseObjectDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodBigInt:
          return (0, bigint_1.parseBigintDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodBoolean:
          return (0, boolean_1.parseBooleanDef)();
        case zod_1.ZodFirstPartyTypeKind.ZodDate:
          return (0, date_1.parseDateDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodUndefined:
          return (0, undefined_1.parseUndefinedDef)();
        case zod_1.ZodFirstPartyTypeKind.ZodNull:
          return (0, null_1.parseNullDef)(refs);
        case zod_1.ZodFirstPartyTypeKind.ZodArray:
          return (0, array_1.parseArrayDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodUnion:
        case zod_1.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
          return (0, union_1.parseUnionDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodIntersection:
          return (0, intersection_1.parseIntersectionDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodTuple:
          return (0, tuple_1.parseTupleDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodRecord:
          return (0, record_1.parseRecordDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodLiteral:
          return (0, literal_1.parseLiteralDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodEnum:
          return (0, enum_1.parseEnumDef)(def);
        case zod_1.ZodFirstPartyTypeKind.ZodNativeEnum:
          return (0, nativeEnum_1.parseNativeEnumDef)(def);
        case zod_1.ZodFirstPartyTypeKind.ZodNullable:
          return (0, nullable_1.parseNullableDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodOptional:
          return (0, optional_1.parseOptionalDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodMap:
          return (0, map_1.parseMapDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodSet:
          return (0, set_1.parseSetDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodLazy:
          return parseDef(def.getter()._def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodPromise:
          return (0, promise_1.parsePromiseDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodNaN:
        case zod_1.ZodFirstPartyTypeKind.ZodNever:
          return (0, never_1.parseNeverDef)();
        case zod_1.ZodFirstPartyTypeKind.ZodEffects:
          return (0, effects_1.parseEffectsDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodAny:
          return (0, any_1.parseAnyDef)();
        case zod_1.ZodFirstPartyTypeKind.ZodUnknown:
          return (0, unknown_1.parseUnknownDef)();
        case zod_1.ZodFirstPartyTypeKind.ZodDefault:
          return (0, default_1.parseDefaultDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodBranded:
          return (0, branded_1.parseBrandedDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodCatch:
          return (0, catch_1.parseCatchDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodPipeline:
          return (0, pipeline_1.parsePipelineDef)(def, refs);
        case zod_1.ZodFirstPartyTypeKind.ZodFunction:
        case zod_1.ZodFirstPartyTypeKind.ZodVoid:
        case zod_1.ZodFirstPartyTypeKind.ZodSymbol:
          return;
        default:
          return /* @__PURE__ */ ((_) => {
          })(typeName);
      }
    }, addMeta = (def, refs, jsonSchema) => (def.description && (jsonSchema.description = def.description, refs.markdownDescription && (jsonSchema.markdownDescription = def.description)), jsonSchema);
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/Options.js
var require_Options = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/Options.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getDefaultOptions = exports.defaultOptions = void 0;
    exports.defaultOptions = {
      name: void 0,
      $refStrategy: "root",
      basePath: ["#"],
      effectStrategy: "input",
      pipeStrategy: "all",
      dateStrategy: "string",
      definitionPath: "definitions",
      target: "jsonSchema7",
      strictUnions: !1,
      definitions: {},
      errorMessages: !1,
      markdownDescription: !1,
      emailStrategy: "format:email"
    };
    var getDefaultOptions = (options) => typeof options == "string" ? Object.assign(Object.assign({}, exports.defaultOptions), { name: options }) : Object.assign(Object.assign({}, exports.defaultOptions), options);
    exports.getDefaultOptions = getDefaultOptions;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/Refs.js
var require_Refs = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/Refs.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getRefs = void 0;
    var Options_1 = require_Options(), getRefs = (options) => {
      let _options = (0, Options_1.getDefaultOptions)(options), currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
      return Object.assign(Object.assign({}, _options), { currentPath, propertyPath: void 0, seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])) });
    };
    exports.getRefs = getRefs;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/zodToJsonSchema.js
var require_zodToJsonSchema = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/src/zodToJsonSchema.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.zodToJsonSchema = void 0;
    var parseDef_1 = require_parseDef(), Refs_1 = require_Refs(), zodToJsonSchema = (schema, options) => {
      var _a;
      let refs = (0, Refs_1.getRefs)(options), definitions = typeof options == "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name2, schema2]) => {
        var _a2;
        return Object.assign(Object.assign({}, acc), { [name2]: (_a2 = (0, parseDef_1.parseDef)(schema2._def, Object.assign(Object.assign({}, refs), { currentPath: [...refs.basePath, refs.definitionPath, name2] }), !0)) !== null && _a2 !== void 0 ? _a2 : {} });
      }, {}) : void 0, name = typeof options == "string" ? options : options?.name, main = (_a = (0, parseDef_1.parseDef)(schema._def, name === void 0 ? refs : Object.assign(Object.assign({}, refs), { currentPath: [...refs.basePath, refs.definitionPath, name] }), !1)) !== null && _a !== void 0 ? _a : {}, combined = name === void 0 ? definitions ? Object.assign(Object.assign({}, main), { [refs.definitionPath]: definitions }) : main : {
        $ref: [
          ...refs.$refStrategy === "relative" ? [] : refs.basePath,
          refs.definitionPath,
          name
        ].join("/"),
        [refs.definitionPath]: Object.assign(Object.assign({}, definitions), { [name]: main })
      };
      return refs.target === "jsonSchema7" ? combined.$schema = "http://json-schema.org/draft-07/schema#" : refs.target === "jsonSchema2019-09" && (combined.$schema = "https://json-schema.org/draft/2019-09/schema#"), combined;
    };
    exports.zodToJsonSchema = zodToJsonSchema;
  }
});

// ../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/index.js
var require_zod_to_json_schema = __commonJS({
  "../../node_modules/.pnpm/zod-to-json-schema@3.21.4_zod@3.22.3/node_modules/zod-to-json-schema/index.js"(exports) {
    "use strict";
    init_cjs_shims();
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.zodToJsonSchema = void 0;
    var zodToJsonSchema_1 = require_zodToJsonSchema();
    Object.defineProperty(exports, "zodToJsonSchema", { enumerable: !0, get: function() {
      return zodToJsonSchema_1.zodToJsonSchema;
    } });
    exports.default = zodToJsonSchema_1.zodToJsonSchema;
  }
});

export {
  require_zod_to_json_schema
};
//# sourceMappingURL=chunk-QSUS3GJF.js.map
